#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/loff.h"
#include "<inc>/limnmmu.h"

var CachedSegmentListHead 0
var CachedSegmentListTail 0

fn RemoveCachedSegment { seg -- }
	seg@ UnrefSegment
	0 seg@ Segment_VNode + @ VNode_CachedTextSegment + !
	0 seg@ Segment_VNode + !

	auto ls
	seg@ Segment_Prev + @ ls!

	auto ns
	seg@ Segment_Next + @ ns!

	if (ls@)
		ns@ ls@ Segment_Next + !
	end

	if (ns@)
		ls@ ns@ Segment_Prev + !
	end

	if (CachedSegmentListHead@ seg@ ==)
		ns@ CachedSegmentListHead!
	end

	if (CachedSegmentListTail@ seg@ ==)
		ls@ CachedSegmentListTail!
	end
end

fn ReclaimCachedText { -- cleared }
	auto bytes
	0 bytes!

	auto rs
	InterruptDisable rs!

	auto seg
	CachedSegmentListHead@ seg!

	0 cleared!

	while (seg@)
		auto vnode
		seg@ Segment_VNode + @ vnode!

		if (vnode@ VNodeOwned)
			seg@ Segment_Next + @ seg!
			continue
		end

		vnode@ VNodeRef

		if (vnode@ VNodeLock)
			vnode@ VNodeUnref
			rs@ InterruptRestore
			return
		end

		if (vnode@ VNode_CachedTextSegment + @ 0 ==)
			seg@ Segment_Next + @ seg!
			vnode@ VNodePut
			continue
		end

		if (seg@ Segment_Refs + @ 1 ==)
			seg@ RemoveCachedSegment

			1 cleared!
			vnode@ VNodePut

			rs@ InterruptRestore

			return
		end

		vnode@ VNodePut
		seg@ Segment_Next + @ seg!
	end

	rs@ InterruptRestore
end

fn GetEntry { header vnode loff -- ok }
	auto entrysym
	header@ LOFFHeader_EntrySymbol + @ entrysym!

	if (entrysym@ 0xFFFFFFFF ==)
		-ENOEXEC ok!
		return
	end

	auto symoff
	header@ LOFFHeader_SymbolTableOffset + @ symoff!

	auto sym
	LOFFSymbol_SIZEOF Malloc sym!

	if (sym@ iserr)
		-ENOMEM ok!
		return
	end

	entrysym@ LOFFSymbol_SIZEOF * symoff +=

	auto bytes

	0 sym@ LOFFSymbol_SIZEOF symoff@ vnode@ VRead bytes!

	if (bytes@ LOFFSymbol_SIZEOF s<)
		if (bytes@ iserr)
			bytes@ ok!
		end else
			-ENOEXEC ok!
		end
		sym@ Free
		return
	end

	if (sym@ LOFFSymbol_Type + @ LOFFGLOBAL ~=)
		-ENOEXEC ok!
		sym@ Free
		return
	end

	if (sym@ LOFFSymbol_Section + @ LOFFTEXT ~=)
		-ENOEXEC ok!
		sym@ Free
		return
	end

	sym@ LOFFSymbol_Value + @ loff@ LOFFSummary_Entry + !

	sym@ Free

	0 ok!
end

struct LOFFSummary
	4 TextVAddr
	4 TextOffset
	4 TextSize
	4 DataVAddr
	4 DataOffset
	4 DataSize
	4 BSSVAddr
	4 BSSSize
	4 Entry
	4 TextSeg
	4 DataSeg
	4 BSSSeg
	4 UData
endstruct

fn ParseLOFF { pm vnode -- loff }
	LOFFSummary_SIZEOF Malloc loff!

	if (loff@ iserr)
		return
	end

	auto header
	LOFFHeader_SIZEOF Malloc header!

	if (header@ iserr)
		loff@ Free
		-ENOMEM loff!
		return
	end

	auto bytes

	0 header@ LOFFHeader_SIZEOF 0 vnode@ VRead bytes!

	if (bytes@ LOFFHeader_SIZEOF s<)
		loff@ Free
		if (bytes@ iserr)
			bytes@ loff!
		end else
			-ENOEXEC loff!
		end
		header@ Free
		return
	end

	if (header@ LOFFHeader_Magic + @ LOFFMagic ~=)
		loff@ Free
		-ENOEXEC loff!
		header@ Free
		return
	end

	if (header@ LOFFHeader_TargetArchitecture + @ LOFFArch ~=)
		loff@ Free
		-ENOEXEC loff!
		header@ Free
		return
	end

	auto ok
	header@ vnode@ loff@ GetEntry ok!
	if (ok@ iserr)
		header@ Free
		loff@ Free
		ok@ loff!
		return
	end

	auto th
	header@ LOFFHeader_TextHeader + @ th!

	auto dh
	header@ LOFFHeader_DataHeader + @ dh!

	auto bh
	header@ LOFFHeader_BSSHeader + @ bh!

	header@ Free

	LOFFSectionHeader_SIZEOF Malloc header!

	if (header@ iserr)
		loff@ Free
		header@ loff!
		return
	end

	0 header@ LOFFSectionHeader_SIZEOF th@ vnode@ VRead bytes!

	if (bytes@ LOFFSectionHeader_SIZEOF s<)
		loff@ Free
		if (bytes@ iserr)
			bytes@ loff!
		end else
			-ENOEXEC loff!
		end
		header@ Free
		return
	end

	auto vaddr
	auto offset

	header@ LOFFSectionHeader_LinkedAddress + @ vaddr!
	vaddr@ loff@ LOFFSummary_TextVAddr + !
	if (vaddr@ 4095 &)
		loff@ Free
		header@ Free
		-ENOEXEC loff!
		return
	end

	vaddr@ loff@ LOFFSummary_Entry + +=

	header@ LOFFSectionHeader_SectionOffset + @ offset!
	offset@ loff@ LOFFSummary_TextOffset + !
	if (offset@ 0x3 &)
		loff@ Free
		header@ Free
		-ENOEXEC loff!
		return
	end
	
	header@ LOFFSectionHeader_SectionSize + @ loff@ LOFFSummary_TextSize + !

	0 header@ LOFFSectionHeader_SIZEOF dh@ vnode@ VRead bytes!

	if (bytes@ LOFFSectionHeader_SIZEOF s<)
		loff@ Free
		if (bytes@ iserr)
			bytes@ loff!
		end else
			-ENOEXEC loff!
		end
		header@ Free
		return
	end

	header@ LOFFSectionHeader_LinkedAddress + @ vaddr!
	vaddr@ loff@ LOFFSummary_DataVAddr + !
	if (vaddr@ 4095 &)
		loff@ Free
		header@ Free
		-ENOEXEC loff!
		return
	end

	header@ LOFFSectionHeader_SectionOffset + @ offset!
	offset@ loff@ LOFFSummary_DataOffset + !
	if (offset@ 0x3 &)
		loff@ Free
		header@ Free
		-ENOEXEC loff!
		return
	end

	header@ LOFFSectionHeader_SectionSize + @ loff@ LOFFSummary_DataSize + !

	0 header@ LOFFSectionHeader_SIZEOF bh@ vnode@ VRead bytes!

	if (bytes@ LOFFSectionHeader_SIZEOF s<)
		loff@ Free
		if (bytes@ iserr)
			bytes@ loff!
		end else
			-ENOEXEC loff!
		end
		header@ Free
		return
	end

	header@ LOFFSectionHeader_LinkedAddress + @ vaddr!
	vaddr@ loff@ LOFFSummary_BSSVAddr + !
	if (vaddr@ 4095 &)
		loff@ Free
		header@ Free
		-ENOEXEC loff!
		return
	end

	header@ LOFFSectionHeader_SectionSize + @ loff@ LOFFSummary_BSSSize + !

	header@ Free
end

(* look through udvec and calculate how much memory needs to be appended to the end of
the process's data section in order to accomodate the udata *)
fn VecSize { udvec udcnt -- bytes }
	udcnt@ UDVec_SIZEOF * bytes! (* make room for table *)

	auto i
	0 i!

	while (i@ udcnt@ <)
		udvec@ UDVec_Size + @ bytes +=

		UDVec_SIZEOF udvec +=
		1 i +=
	end
end

fn VecCopy { pm udvec udcnt ubase -- ok }
	auto i
	0 i!

	auto udata
	ubase@ udcnt@ UDVec_SIZEOF * + udata!

	auto mpm
	CurrentThread@ Thread_Process + @ Process_Pagemap + @ mpm!

	auto tdvec
	udcnt@ UDVec_SIZEOF * Malloc tdvec!

	if (tdvec@ iserr)
		tdvec@ ok!
		return
	end

	auto p
	tdvec@ p!

	auto sz

	0 ok!

	while (i@ udcnt@ <)
		udvec@ UDVec_Size + @ sz!

		sz@ p@ UDVec_Size + !
		udata@ p@ UDVec_Ptr + !

		if (sz@ 0 ~=)
			pm@ udata@ mpm@ udvec@ UDVec_Ptr + @ sz@ VMMemcpy ok!

			if (ok@ iserr)
				tdvec@ Free
				return
			end
		end

		sz@ udata +=
		UDVec_SIZEOF p +=
		UDVec_SIZEOF udvec +=
		1 i +=
	end

	pm@ ubase@ tdvec@ udcnt@ UDVec_SIZEOF * VMCopyout ok!

	tdvec@ Free
end

fn LoadLOFF { proc vnode udvec udcnt -- loff }
	auto pm
	proc@ Process_Pagemap + @ pm!

	pm@ vnode@ ParseLOFF loff!

	if (loff@ iserr)
		return
	end

	(* start trying to copy sections in and zero BSS *)

	auto textseg
	auto dataseg
	auto bssseg

	auto sz

	loff@ LOFFSummary_TextSize + @ sz!

	auto cts
	vnode@ VNode_CachedTextSegment + @ cts!

	if (cts@)
		cts@ textseg!
	end else
		sz@ VMAllocSegment textseg!

		if (textseg@ iserr)
			loff@ Free
			textseg@ loff!
			return
		end
	end

	auto ok

	proc@ textseg@ 0 OpenSegment ok!

	if (ok@ 0 ~=)
		"LoadLOFF: open text\n" Panic
	end

	proc@ 0 loff@ LOFFSummary_TextVAddr + @ 1 MapSegment drop ok!

	if (ok@ iserr)
		textseg@ UnrefSegment

		loff@ Free
		ok@ loff!
		return
	end

	textseg@ loff@ LOFFSummary_TextSeg + !

	loff@ LOFFSummary_DataSize + @ sz!

	udvec@ udcnt@ VecSize sz +=

	sz@ VMAllocSegment dataseg!

	if (dataseg@ iserr)
		textseg@ UnrefSegment

		loff@ Free
		dataseg@ loff!
		return
	end

	proc@ dataseg@ OSEG_WRITABLE OpenSegment ok!

	if (ok@ 1 ~=)
		"LoadLOFF: open data\n" Panic
	end

	proc@ 1 loff@ LOFFSummary_DataVAddr + @ 1 MapSegment drop ok!

	if (ok@ iserr)
		textseg@ UnrefSegment
		dataseg@ UnrefSegment

		loff@ Free
		ok@ loff!
		return
	end

	dataseg@ loff@ LOFFSummary_DataSeg + !

	loff@ LOFFSummary_BSSSize + @ sz!

	sz@ VMAllocSegment bssseg!

	if (bssseg@ iserr)
		textseg@ UnrefSegment
		dataseg@ UnrefSegment

		loff@ Free
		bssseg@ loff!
		return
	end

	proc@ bssseg@ OSEG_WRITABLE OpenSegment ok!

	if (ok@ 2 ~=)
		"LoadLOFF: open bss\n" Panic
	end

	proc@ 2 loff@ LOFFSummary_BSSVAddr + @ 1 MapSegment drop ok!

	if (ok@ iserr)
		textseg@ UnrefSegment
		dataseg@ UnrefSegment
		bssseg@ UnrefSegment

		loff@ Free
		ok@ loff!
		return
	end

	bssseg@ loff@ LOFFSummary_BSSSeg + !

	auto bytes

	if (cts@ ~~)
		pm@ loff@ LOFFSummary_TextVAddr + @ loff@ LOFFSummary_TextSize + @ loff@ LOFFSummary_TextOffset + @ vnode@ VRead bytes!

		if (bytes@ loff@ LOFFSummary_TextSize + @ s<)
			textseg@ UnrefSegment
			dataseg@ UnrefSegment
			bssseg@ UnrefSegment

			loff@ Free
			-ENOEXEC loff!
			return
		end

		auto rs
		InterruptDisable rs!

		textseg@ RefSegment

		textseg@ vnode@ VNode_CachedTextSegment + !
		vnode@ textseg@ Segment_VNode + !

		if (CachedSegmentListTail@ 0 ==)
			textseg@ CachedSegmentListHead!
			textseg@ CachedSegmentListTail!
		end else
			CachedSegmentListTail@ textseg@ Segment_Prev + !
			textseg@ CachedSegmentListTail@ Segment_Next + !
			textseg@ CachedSegmentListTail!
		end

		rs@ InterruptRestore
	end

	pm@ loff@ LOFFSummary_DataVAddr + @ loff@ LOFFSummary_DataSize + @ loff@ LOFFSummary_DataOffset + @ vnode@ VRead bytes!

	if (bytes@ loff@ LOFFSummary_DataSize + @ s<)
		textseg@ VMSegDestruct drop
		textseg@ Free

		dataseg@ VMSegDestruct drop
		dataseg@ Free

		bssseg@ VMSegDestruct drop
		bssseg@ Free

		loff@ Free
		-ENOEXEC loff!
		return
	end

	pm@ loff@ LOFFSummary_BSSVAddr + @ loff@ LOFFSummary_BSSSize + @ 0 VMMemset ok!

	if (ok@ iserr)
		textseg@ VMSegDestruct drop
		textseg@ Free

		dataseg@ VMSegDestruct drop
		dataseg@ Free

		bssseg@ VMSegDestruct drop
		bssseg@ Free

		loff@ Free
		ok@ loff!
		return
	end

	auto udata

	if (udcnt@)
		loff@ LOFFSummary_DataVAddr + @ loff@ LOFFSummary_DataSize + @ + udata!

		pm@
		udvec@
		udcnt@
		udata@
		VecCopy ok!

		if (ok@ iserr)
			textseg@ VMSegDestruct drop
			textseg@ Free

			dataseg@ VMSegDestruct drop
			dataseg@ Free

			bssseg@ VMSegDestruct drop
			bssseg@ Free

			loff@ Free
			ok@ loff!
			return
		end
	end else
		0 udata!
	end

	udata@ loff@ LOFFSummary_UData + !
end

fn VNewProcess1 { vnode name udvec udcnt -- process }
	name@ ProcessNew process!

	if (process@ iserr)
		return
	end

	auto ok
	process@ VMPagemapAlloc ok!

	if (ok@ iserr)
		process@ ProcessFreeSlot
		ok@ process!
		return
	end

	auto loff

	process@ vnode@ udvec@ udcnt@ LoadLOFF loff!

	if (loff@ iserr)
		process@ ProcessFreeSlot
		loff@ process!
		return
	end

	loff@ LOFFSummary_Entry + @ loff@ LOFFSummary_UData + @ udcnt@ process@ 0 ProcessAddMainThread ok!

	if (ok@ iserr)
		process@ ProcessFreeSlot

		loff@ LOFFSummary_TextSeg + @ VMSegDestruct drop
		loff@ LOFFSummary_TextSeg + @ Free

		loff@ LOFFSummary_DataSeg + @ VMSegDestruct drop
		loff@ LOFFSummary_DataSeg + @ Free

		loff@ LOFFSummary_BSSSeg + @ VMSegDestruct drop
		loff@ LOFFSummary_BSSSeg + @ Free

		loff@ Free

		ok@ process!

		return
	end

	loff@ Free

	auto p
	CurrentThread@ Thread_Process + @ p!

	p@ Process_TTY + @ process@ Process_TTY + !

	p@ Process_UID + @ process@ Process_UID + !

	if (vnode@ VNode_Permissions + @ SUID &)
		if (vnode@ VNode_Mount + @ Mount_Flags + @ FS_NOUID & ~~)
			vnode@ VNode_UID + @ process@ Process_EUID + !
		end
	end else
		p@ Process_UID + @ process@ Process_EUID + !
	end

	p@ process@ Process_Parent + !

	auto cwd

	p@ Process_CWDVNode + @ cwd!

	cwd@ VNodeRef

	cwd@ process@ Process_CWDVNode + !

	process@ Process_CWDPathString + p@ Process_CWDPathString + CWDPATHLEN 1 - strncpy
end

fn VNewProcess { vnode name filp0 filp1 filp2 mode udvec udcnt -- process }
	if (vnode@ VNode_Type + @ VNODE_DIR ==)
		-EISDIR process!
		return
	end

	vnode@ WORLD_X CurrentThread@ Thread_Process + @ Process_UID + @ VForbidden process!

	if (process@ iserr)
		return
	end

	vnode@ name@ udvec@ udcnt@ VNewProcess1 process!

	if (process@ iserr)
		return
	end

	auto p
	CurrentThread@ Thread_Process + @ p!

	auto ofilen
	process@ Process_OFiles + ofilen!

	if (mode@ NP_INHERIT ==)
		auto i
		0 i!

		auto ofile
		p@ Process_OFiles + ofile!

		while (i@ OFILEMAX <)
			if (ofile@@)
				if (ofile@@ FileP_Flags + @ O_CLOEXEC & ~~)
					ofile@@ FDup
					ofile@@ ofilen@!
				end
			end

			4 ofile +=
			4 ofilen +=
			1 i +=
		end
	end elseif (mode@ NP_SPECIFY ==)
		if (filp0@)
			filp0@ FDup
			filp0@ ofilen@ 0 + !
		end

		if (filp1@)
			filp1@ FDup
			filp1@ ofilen@ 4 + !
		end

		if (filp2@)
			filp2@ FDup
			filp2@ ofilen@ 8 + !
		end
	end

	auto ity
	p@ Process_IgnoreTTY + @ ity!

	if (ity@ TTYI_CHILD_ALL &)
		TTYI_ALL process@ Process_IgnoreTTY + !
	end elseif (ity@ TTYI_CHILD_IGN &)
		TTYI_IGN process@ Process_IgnoreTTY + !
	end else
		ity@ process@ Process_IgnoreTTY + !
	end

	p@ Process_UMask + @ process@ Process_UMask + !

	process@ Process_MainThread + @ ThreadReady
end