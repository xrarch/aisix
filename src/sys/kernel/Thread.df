#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/context.h"

table Threads[THREADMAX]
public Threads

table Processes[PROCMAX]
public Processes

var CurrentThread 0
public CurrentThread

var KernelProcess 0
public KernelProcess

var InitProcess 0

const KERNELPID 1

extern AISIXInitialThread { -- }

fn ThreadInit { -- }
	PROCMAX THREADMAX "max %d threads, %d processes\n" Printf

	auto process
	pointerof AISIXInitialThread "kernel" ProcessNew process!

	if (process@ iserr KernelProcess@ process@ ~= ||)
		"couldn't set up kernel process\n" Panic
	end

	process@ Process_MainThread + @ ThreadReady
end

fn private ThreadAllocate { -- thread }
	auto tid
	0 tid!

	-ENOMEM thread!

	while (tid@ THREADMAX <)
		auto rs
		InterruptDisable rs!

		if ([tid@]Threads@ 0 ==)
			auto ts
			Thread_SIZEOF Calloc ts!

			if (ts@ iserr)
				rs@ InterruptRestore
				return
			end

			TS_NOTREADY ts@ Thread_Status + !

			tid@ ts@ Thread_TID + !

			ts@ [tid@]Threads!

			rs@ InterruptRestore
			ts@ thread!
			return
		end

		rs@ InterruptRestore

		1 tid +=
	end
end

fn private ThreadFreeSlot { thread -- }
	auto tid
	thread@ Thread_TID + @ tid!

	0 [tid@]Threads!

	thread@ Free
end

fn ThreadFree { thread -- }
	KERNELSTACKPAGES thread@ Thread_KernelStack + @ PMMFree

	thread@ ThreadFreeSlot
end

(* if the thread is in the kernel,
wake it up and let it finish up whatever it's doing,
and maybe find out it was killed and do something special.
it will eventually call ThreadExit when it returns to
the exception vectoring code.
this prevents locks from being held forever, buffers never being
freed, etc.
however, user threads can just be killed, and their
resources immediately freed.
if the process has no more threads left, kill it too, unless
it already exited. *)

fn ThreadKill { thread -- }
	if (thread@ Thread_Process + @ KernelProcess@ ==)
		"tried to kill a kernel thread!\n" Panic
	end

	if (thread@ CurrentThread@ ==)
		"tried to kill self\n" Panic
	end

	auto rs
	InterruptDisable rs!

	auto thst
	thread@ Thread_Status + @ thst!

	auto notnow
	0 notnow!

	if (thread@ Thread_InKernel + @)
		1 notnow!
	end

	if (notnow@ ~~)
		thread@ ThreadFree

		auto process
		thread@ Thread_Process + @ process!

		if (process@ Process_Threads + @ 1 <=)
			0 process@ Process_Threads + !
			
			if (process@ Process_Exited + @ ~~)
				0 ProcessExit
			end
		end else
			1 process@ Process_Threads + -=
		end
	end else
		if (thst@ TS_EVENT ==)
			(* remove from whatever EventQueue its waiting in *)
			auto eq
			thread@ Thread_EvQ + @ eq!

			auto pw
			thread@ Thread_PrevWaiter + @ pw!

			auto nw
			thread@ Thread_NextWaiter + @ nw!

			if (pw@)
				nw@ pw@ Thread_NextWaiter + !
			end

			if (nw@)
				pw@ nw@ Thread_PrevWaiter + !
			end

			if (eq@ EventQueue_FirstWaiter + @ thread@ ==)
				nw@ eq@ EventQueue_FirstWaiter + !
			end

			if (eq@ EventQueue_LastWaiter + @ thread@ ==)
				pw@ eq@ EventQueue_LastWaiter + !
			end
		end

		1 thread@ Thread_Killed + !
		TS_READY thread@ Thread_Status + !
	end

	rs@ InterruptRestore
end

fn ThreadExit { -- }
	auto rs
	InterruptDisable rs!

	auto thread
	CurrentThread@ thread!

	auto process
	thread@ Thread_Process + @ process!

	if (process@ Process_Threads + @ 1 <=)
		0 process@ Process_Threads + !
		
		if (process@ Process_Exited + @ ~~)
			0 ProcessExit
		end
	end else
		1 process@ Process_Threads + -=
	end

	thread@ ThreadFree

	0 thread@ Thread_Status + !

	JumpIntoScheduler

	"exit returned\n" Panic
end

fn ThreadNew { process entry name -- thread }
	ThreadAllocate thread!

	if (thread@ iserr)
		return
	end

	process@ thread@ Thread_Process + !

	auto stack
	KERNELSTACKPAGES PMMCalloc stack!

	if (stack@ iserr)
		thread@ ThreadFreeSlot
		stack@ thread!
		return
	end

	stack@ thread@ Thread_KernelStack + !

	auto uc

	auto vst

	KERNELSTACKPAGES 4096 * stack@ + dup thread@ Thread_KernelStackTop + ! uc!

	entry@ uc@ CPUContextPrepare thread@ Thread_Context + !

	thread@ Thread_Name + name@ THREADNAMELEN 1 - strncpy

	1 process@ Process_Threads + +=
end

fn ThreadReady { thread -- }
	TS_READY thread@ Thread_Status + !
end

fn KernelThreadNew { entry name -- thread }
	KernelProcess@ entry@ name@ ThreadNew thread!
end

extern CPUIdle { -- }

var SchedulerContext 0

(* scheduler *)
fn Scheduler { -- }
	"entering scheduler loop\n" Printf

	auto rs
	auto thread

	InterruptEnable

	while (1)
		auto i
		0 i!

		auto ran
		0 ran!

		while (i@ THREADMAX <)
			InterruptDisable rs!

			[i@]Threads@ thread!

			if (thread@ 0 ==)
				1 i +=
				rs@ InterruptRestore
				continue
			end

			if (thread@ Thread_Status + @ TS_READY ~=)
				1 i +=
				rs@ InterruptRestore
				continue
			end

			1 ran!

			thread@ CurrentThread!

			TS_RUNNING thread@ Thread_Status + !

			SchedulerContext thread@ Thread_Context + @ cswtch

			0 CurrentThread!

			1 i +=

			rs@ InterruptRestore
		end

		if (ran@ ~~)
			CPUIdle
		end
	end
end

fn JumpIntoScheduler { -- }
	if (CurrentThread@ Thread_Status + @ TS_RUNNING ==)
		"JumpIntoScheduler: thread is running\n" Panic
	end

	CurrentThread@ Thread_Context + SchedulerContext@ cswtch
end

fn Yield { -- }
	auto rs
	InterruptDisable rs!

	TS_READY CurrentThread@ Thread_Status + !

	JumpIntoScheduler

	rs@ InterruptRestore
end

fn SleepFor { ms -- killed }
	auto rs
	InterruptDisable rs!

	TimerUptime ms@ + CurrentThread@ Thread_WaitChan + !

	TS_TIMER CurrentThread@ Thread_Status + !

	JumpIntoScheduler

	rs@ InterruptRestore

	CurrentThread@ Thread_Killed + @ killed!
end

fn WakeupTimer { uptime -- }
	auto i
	0 i!

	while (i@ THREADMAX <)
		auto rs
		InterruptDisable rs!

		auto thr
		[i@]Threads@ thr!

		if (thr@)
			if (thr@ Thread_Status + @ TS_TIMER ==)
				if (uptime@ thr@ Thread_WaitChan + @ >=)
					0 thr@ Thread_WaitChan + !
					TS_READY thr@ Thread_Status + !
				end
			end
		end

		rs@ InterruptRestore

		1 i +=
	end
end

extern KDebug { -- }

fn WaitQueue { evq -- killed }
	auto rs
	InterruptDisable rs!

	if (CurrentThread@ Thread_Killed + @)
		rs@ InterruptRestore
		1 killed!
		return
	end

	auto lw
	evq@ EventQueue_LastWaiter + @ lw!

	if (lw@)
		CurrentThread@ lw@ Thread_NextWaiter + !
		lw@ CurrentThread@ Thread_PrevWaiter + !
	end else
		(* no last waiter means no first waiter, set myself as first waiter *)
		CurrentThread@ evq@ EventQueue_FirstWaiter + !
	end

	CurrentThread@ evq@ EventQueue_LastWaiter + !

	TS_EVENT CurrentThread@ Thread_Status + !

	evq@ CurrentThread@ Thread_EvQ + !

	JumpIntoScheduler

	0 CurrentThread@ Thread_EvQ + !

	CurrentThread@ Thread_Killed + @ killed!

	rs@ InterruptRestore
end

fn WakeQueue { evq -- }
	auto rs
	InterruptDisable rs!

	auto w
	evq@ EventQueue_FirstWaiter + @ w!

	if (w@ ~~)
		rs@ InterruptRestore
		return
	end

	TS_READY w@ Thread_Status + !

	auto nw
	w@ Thread_NextWaiter + @ nw!

	nw@ evq@ EventQueue_FirstWaiter + !

	if (nw@ 0 ==)
		0 evq@ EventQueue_LastWaiter + !
	end else
		0 nw@ Thread_PrevWaiter + !
	end

	if (evq@ EventQueue_LastWaiter + @ w@ ==)
		0 evq@ EventQueue_LastWaiter + !
	end

	0 w@ Thread_NextWaiter + !
	0 w@ Thread_PrevWaiter + !

	rs@ InterruptRestore
end

(* =========== process management =========== *)

var NextPID 1

fn private ProcessAllocate { -- process }
	auto i
	0 i!

	if (NextPID@ 0xFFFFFFFF ==)
		"ProcessAllocate: ran out of PIDs, somebody redo this algorithm\n" Panic
	end

	-ENOMEM process!

	while (i@ PROCMAX <)
		auto rs
		InterruptDisable rs!

		if ([i@]Processes@ 0 ==)
			auto ps
			Process_SIZEOF Calloc ps!

			if (ps@ iserr)
				rs@ InterruptRestore
				return
			end

			i@ ps@ Process_Index + !

			NextPID@ ps@ Process_PID + !

			1 NextPID +=

			ps@ [i@]Processes!

			rs@ InterruptRestore
			ps@ process!
			return
		end

		rs@ InterruptRestore

		1 i +=
	end
end

fn private ProcessFreeSlot { process -- }
	auto index
	process@ Process_Index + @ index!

	0 [index@]Processes!

	[index@]Processes@ Free
end

fn ProcessNew { entry name -- process }
	ProcessAllocate process!

	if (process@ iserr)
		return
	end

	process@ Process_Name + name@ PROCNAMELEN 1 - strncpy

	auto kernel
	0 kernel!

	if (process@ Process_PID + @ KERNELPID ==)
		1 kernel!
	end

	if (CurrentThread@)
		auto parent
		CurrentThread@ Thread_Process + @ parent!

		parent@ process@ Process_Parent + !

		parent@ Process_UserID + @ dup
		process@ Process_UserID + !
		process@ Process_EUserID + !
	end

	auto mthread

	process@ entry@ "main" ThreadNew mthread!

	mthread@ process@ Process_MainThread + !

	if (mthread@ iserr)
		process@ ProcessFreeSlot
		mthread@ process!
		return
	end

	if (kernel@)
		process@ KernelProcess!
		1 kernel!
	end
end

fn ProcessFreeResources { process -- }
	if (process@ Process_Threads + @ 0 >)
		"ProcessFreeResources: process still had extant threads\n" Panic
	end

	if (process@ Process_Mapped + @)
		process@ Process_TextPages + @ process@ Process_TextPhysical + @ PMMFree
		process@ Process_DataPages + @ process@ Process_DataPhysical + @ PMMFree
		process@ Process_BSSPages + @ process@ Process_BSSPhysical + @ PMMFree
	end

	(* don't free slot now, will be needed later *)
end

fn ProcessExit { ret -- }
	auto process
	CurrentThread@ Thread_Process + @ process!

	ret@ process@ ProcessKill
end

fn ProcessKill { ret process -- }
	if (process@ KernelProcess@ ==)
		"kernel process killed!\n" Panic
	end

	auto rs
	InterruptDisable rs!

	1 process@ Process_Exited + !

	ret@ process@ Process_ReturnValue + !

	auto i
	0 i!

	while (i@ THREADMAX <)
		auto thread
		[i@]Threads@ thread!

		if (thread@)
			if (thread@ Thread_Process + @ process@ ==)
				thread@ ThreadKill

				1 process@ Process_Threads + -=
			end
		end

		1 i +=
	end

	if (process@ Process_Threads + @ 0 ~=)
		"threads weren't hard enough\n" Panic
	end

	(* all of the userspace threads will never run again, and the kernel ones will exit
	instead of returning home, so it's safe to free the process image now *)
	if (process@ Process_Mapped + @)
		process@ Process_TextPages + @ process@ Process_TextPhysical + @ PMMFree
		process@ Process_DataPages + @ process@ Process_DataPhysical + @ PMMFree
		process@ Process_BSSPages + @ process@ Process_BSSPhysical + @ PMMFree
	end

	(* do wait syscall stuff here *)

	0 i!

	while (i@ PROCMAX <)
		auto child
		[i@]Processes@ child!

		if (child@ 0 ~=)
			if (child@ Process_Parent + @ process@ ==)
				InitProcess@ child@ Process_Parent + !

				(* additional bookkeeping is probably required *)
			end
		end

		1 i +=
	end

	rs@ InterruptRestore
end