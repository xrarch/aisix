#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/context.h"

table Threads[THREADMAX]
public Threads

table Processes[PROCMAX]
public Processes

var CurrentThread 0
public CurrentThread

var KernelProcess 0
public KernelProcess

var InitProcess 0
public InitProcess

const KERNELPID 1

extern AISIXInitialThread { -- }

fn ThreadInit { -- }
	PROCMAX THREADMAX "max %d threads, %d processes\n" Printf

	auto process
	pointerof AISIXInitialThread "kernel" 0 0 ProcessNew process!

	if (process@ iserr KernelProcess@ process@ ~= ||)
		"couldn't set up kernel process\n" Panic
	end

	process@ Process_MainThread + @ ThreadReady
end

fn private ThreadAllocate { -- thread }
	auto tid
	0 tid!

	-ENOMEM thread!

	while (tid@ THREADMAX <)
		auto rs
		InterruptDisable rs!

		if ([tid@]Threads@ 0 ==)
			auto ts
			Thread_SIZEOF Calloc ts!

			if (ts@ iserr)
				rs@ InterruptRestore
				return
			end

			TS_NOTREADY ts@ Thread_Status + !

			tid@ ts@ Thread_TID + !

			ts@ [tid@]Threads!

			rs@ InterruptRestore
			ts@ thread!
			return
		end

		rs@ InterruptRestore

		1 tid +=
	end
end

fn private ThreadFreeSlot { thread -- }
	auto tid
	thread@ Thread_TID + @ tid!

	0 [tid@]Threads!

	thread@ Free
end

fn ThreadFree { thread -- }
	KERNELSTACKPAGES thread@ Thread_KernelStack + @ PMMFree

	thread@ ThreadFreeSlot
end

(* if the thread is in the kernel,
wake it up and let it finish up whatever it's doing,
and maybe find out it was killed and do something special.
it will eventually call ThreadExit when it returns to
the exception vectoring code.
this prevents locks from being held forever, buffers never being
freed, etc.
however, user threads can just be killed, and their
resources immediately freed.
if the process has no more threads left, kill it too, unless
it already exited. *)

fn ThreadKill { thread -- }
	if (thread@ Thread_Process + @ KernelProcess@ ==)
		"tried to kill a kernel thread!\n" Panic
	end

	if (thread@ Thread_Killed + @)
		return
	end

	auto rs
	InterruptDisable rs!

	auto thst
	thread@ Thread_Status + @ thst!

	auto notnow
	0 notnow!

	if (thread@ Thread_InKernel + @)
		1 notnow!
	end

	if (notnow@ ~~)
		thread@ ThreadFree

		auto process
		thread@ Thread_Process + @ process!

		1 process@ Process_Threads + -=

		auto thr
		process@ Process_Threads + @ thr!

		if (process@ Process_MainThread + @ thread@ ==)
			0 process@ Process_MainThread + !
			0 process@ ProcessKill
		end elseif (thr@ 0 ==)
			0 process@ ProcessKill
		end
	end else
		if (thst@ TS_EVENT ==)
			(* remove from whatever EventQueue its waiting in *)
			auto eq
			thread@ Thread_EvQ + @ eq!

			auto pw
			thread@ Thread_PrevWaiter + @ pw!

			auto nw
			thread@ Thread_NextWaiter + @ nw!

			if (pw@)
				nw@ pw@ Thread_NextWaiter + !
			end

			if (nw@)
				pw@ nw@ Thread_PrevWaiter + !
			end

			if (eq@ EventQueue_FirstWaiter + @ thread@ ==)
				nw@ eq@ EventQueue_FirstWaiter + !
			end

			if (eq@ EventQueue_LastWaiter + @ thread@ ==)
				pw@ eq@ EventQueue_LastWaiter + !
			end
		end

		1 thread@ Thread_Killed + !
		TS_READY thread@ Thread_Status + !
	end

	rs@ InterruptRestore
end

fn ThreadExit { -- }
	auto rs
	InterruptDisable rs!

	auto thread
	CurrentThread@ thread!

	auto process
	thread@ Thread_Process + @ process!

	1 process@ Process_Threads + -=

	auto thr
	process@ Process_Threads + @ thr!
	
	if (process@ Process_MainThread + @ thread@ ==)
		0 process@ Process_MainThread + !
		0 ProcessExit
	end	elseif (thr@ 0 ==)
		0 ProcessExit
	end

	0 thread@ Thread_Status + !

	thread@ ThreadFree

	JumpIntoScheduler

	"exit returned\n" Panic
end

fn ThreadNew { process entry name kern pass0 pass1 -- thread }
	ThreadAllocate thread!

	if (thread@ iserr)
		return
	end

	process@ thread@ Thread_Process + !

	auto stack
	KERNELSTACKPAGES PMMCalloc stack!

	if (stack@ iserr)
		thread@ ThreadFreeSlot
		stack@ thread!
		return
	end

	stack@ thread@ Thread_KernelStack + !

	auto uc

	auto vst

	KERNELSTACKPAGES 4096 * stack@ + dup thread@ Thread_KernelStackTop + ! uc!

	pass0@ pass1@ entry@ uc@ kern@ CPUContextPrepare thread@ Thread_Context + !

	thread@ Thread_Name + name@ THREADNAMELEN 1 - strncpy

	1 process@ Process_Threads + +=
end

fn ThreadReady { thread -- }
	TS_READY thread@ Thread_Status + !
end

fn KernelThreadNew { entry name -- thread }
	KernelProcess@ entry@ name@ 1 0 0 ThreadNew thread!
end

extern CPUIdle { -- }

var DebugNextSched 0
public DebugNextSched

var TTYKill 0
public TTYKill

var SchedulerContext 0

(* scheduler *)
fn Scheduler { -- }
	"entering scheduler loop\n" Printf

	auto thread

	while (1)
		auto i
		0 i!

		while (i@ THREADMAX <)
			if (DebugNextSched@)
				0 DebugNextSched!
				KDebug
			end

			if (TTYKill@)
				TTYKill@ KillTTY
				0 TTYKill!
			end

			[i@]Threads@ thread!

			if (thread@ 0 ==)
				1 i +=
				continue
			end

			if (thread@ Thread_Status + @ TS_READY ~=)
				1 i +=
				continue
			end

			thread@ CurrentThread!

			TS_RUNNING thread@ Thread_Status + !

			auto proc
			thread@ Thread_Process + @ proc!

			if (proc@ Process_Mapped + @)
				proc@ PlatformSwitchSeg
			end

			SchedulerContext thread@ Thread_Context + @ cswtch

			0 CurrentThread!

			1 i +=
		end
	end
end

fn JumpIntoScheduler { -- }
	if (CurrentThread@ Thread_Status + @ TS_RUNNING ==)
		"JumpIntoScheduler: thread is running\n" Panic
	end

	CurrentThread@ Thread_Context + SchedulerContext@ cswtch
end

fn Yield { -- }
	auto rs
	InterruptDisable rs!

	TS_READY CurrentThread@ Thread_Status + !

	JumpIntoScheduler

	rs@ InterruptRestore
end

fn SleepFor { ms -- killed }
	auto rs
	InterruptDisable rs!

	TimerUptime ms@ + CurrentThread@ Thread_WaitChan + !

	TS_TIMER CurrentThread@ Thread_Status + !

	JumpIntoScheduler

	rs@ InterruptRestore

	CurrentThread@ Thread_Killed + @ killed!
end

fn WakeupTimer { uptime -- }
	auto i
	0 i!

	while (i@ THREADMAX <)
		auto rs
		InterruptDisable rs!

		auto thr
		[i@]Threads@ thr!

		if (thr@)
			if (thr@ Thread_Status + @ TS_TIMER ==)
				if (uptime@ thr@ Thread_WaitChan + @ >=)
					0 thr@ Thread_WaitChan + !
					TS_READY thr@ Thread_Status + !
				end
			end
		end

		rs@ InterruptRestore

		1 i +=
	end
end

extern KDebug { -- }

fn WaitQueue { evq -- killed }
	auto rs
	InterruptDisable rs!

	if (CurrentThread@ Thread_Killed + @)
		rs@ InterruptRestore
		1 killed!
		return
	end

	auto lw
	evq@ EventQueue_LastWaiter + @ lw!

	if (lw@)
		CurrentThread@ lw@ Thread_NextWaiter + !
		lw@ CurrentThread@ Thread_PrevWaiter + !
	end else
		(* no last waiter means no first waiter, set myself as first waiter *)
		CurrentThread@ evq@ EventQueue_FirstWaiter + !
	end

	CurrentThread@ evq@ EventQueue_LastWaiter + !

	TS_EVENT CurrentThread@ Thread_Status + !

	evq@ CurrentThread@ Thread_EvQ + !

	JumpIntoScheduler

	0 CurrentThread@ Thread_EvQ + !

	CurrentThread@ Thread_Killed + @ killed!

	rs@ InterruptRestore
end

fn WakeQueue { evq -- }
	auto rs
	InterruptDisable rs!

	auto w
	evq@ EventQueue_FirstWaiter + @ w!

	if (w@ ~~)
		rs@ InterruptRestore
		return
	end

	TS_READY w@ Thread_Status + !

	auto nw
	w@ Thread_NextWaiter + @ nw!

	nw@ evq@ EventQueue_FirstWaiter + !

	if (nw@ 0 ==)
		0 evq@ EventQueue_LastWaiter + !
	end else
		0 nw@ Thread_PrevWaiter + !
	end

	if (evq@ EventQueue_LastWaiter + @ w@ ==)
		0 evq@ EventQueue_LastWaiter + !
	end

	0 w@ Thread_NextWaiter + !
	0 w@ Thread_PrevWaiter + !

	rs@ InterruptRestore
end

(* =========== process management =========== *)

fn ProcLock { proc -- killed }
	proc@ Process_Mutex + LockMutex killed!
end

fn ProcUnlock { proc -- }
	proc@ Process_Mutex + UnlockMutex
end

fn LockMe { -- killed }
	CurrentThread@ Thread_Process + @ ProcLock killed!
end

fn UnlockMe { -- }
	CurrentThread@ Thread_Process + @ ProcUnlock
end

var NextPID 1

fn private ProcessAllocate { -- process }
	auto i
	0 i!

	if (NextPID@ 0xFFFFFFFF ==)
		"ProcessAllocate: ran out of PIDs, somebody redo this algorithm\n" Panic
	end

	-ENOMEM process!

	while (i@ PROCMAX <)
		auto rs
		InterruptDisable rs!

		if ([i@]Processes@ 0 ==)
			auto ps
			Process_SIZEOF Calloc ps!

			if (ps@ iserr)
				rs@ InterruptRestore
				return
			end

			i@ ps@ Process_Index + !

			NextPID@ ps@ Process_PID + !

			1 NextPID +=

			ps@ [i@]Processes!

			rs@ InterruptRestore
			ps@ process!
			return
		end

		rs@ InterruptRestore

		1 i +=
	end
end

fn private ProcessFreeSlot { process -- }
	auto index
	process@ Process_Index + @ index!

	0 [index@]Processes!

	process@ Free
end

fn ProcessNew { entry name udata udatasz -- process }
	ProcessAllocate process!

	if (process@ iserr)
		return
	end

	process@ Process_Name + name@ PROCNAMELEN 1 - strncpy

	auto kernel
	0 kernel!

	if (process@ Process_PID + @ KERNELPID ==)
		1 kernel!
	end

	"process" process@ Process_Mutex + InitMutex

	auto mthread

	process@ entry@ "main" kernel@ udata@ udatasz@ ThreadNew mthread!

	mthread@ process@ Process_MainThread + !

	if (mthread@ iserr)
		process@ ProcessFreeSlot
		mthread@ process!
		return
	end

	if (kernel@)
		process@ KernelProcess!
	end
end

fn KillTTY { tty -- }
	auto i
	0 i!

	while (i@ PROCMAX <)
		auto proc
		[i@]Processes@ proc!

		if (proc@)
			if (proc@ Process_IgnoreTTY + @ ~~)
				if (proc@ Process_TTY + @ tty@ ==)
					0 proc@ ProcessKill
				end
			end
		end

		1 i +=
	end
end

fn ProcessExit { ret -- }
	auto process
	CurrentThread@ Thread_Process + @ process!

	ret@ process@ ProcessKill
end

fn private ReparentChildren { process -- }
	auto i
	0 i!

	while (i@ PROCMAX <)
		auto child
		[i@]Processes@ child!

		if (child@ 0 ~=)
			if (child@ Process_Parent + @ process@ ==)
				InitProcess@ child@ Process_Parent + !

				(* additional bookkeeping is probably required *)
			end
		end

		1 i +=
	end
end

fn ProcessKill { ret process -- }
	if (process@ KernelProcess@ ==)
		"kernel process killed!\n" Panic
	end

	if (process@ InitProcess@ ==)
		"init process killed!\n" Panic
	end

	auto rs
	InterruptDisable rs!

	auto i
	0 i!

	if (process@ Process_Exited + @ ~~)
		ret@ process@ Process_ReturnValue + !

		1 process@ Process_Exited + !

		while (i@ THREADMAX <)
			auto thread
			[i@]Threads@ thread!

			if (thread@)
				if (thread@ Thread_Process + @ process@ ==)
					thread@ ThreadKill
				end
			end

			1 i +=
		end

		(* all of the userspace threads will never run again, and the kernel ones will exit
		instead of returning home, so it's safe to free the process image now *)
		if (process@ Process_Mapped + @)
			process@ Process_TextPages + @ process@ Process_TextPhysical + @ PMMFree
			process@ Process_DataPages + @ process@ Process_DataPhysical + @ PMMFree
			0 process@ Process_Mapped + !
		end

		(* do wait syscall stuff here *)
	end

	auto thleft
	process@ Process_Threads + @ thleft!

	rs@ InterruptRestore

	(* do the stuff the last kernel thread would have done if there were any left, which there aren't *)
	if (thleft@ 0 ==)
		process@ Process_Name + "freed proc %s\n" Printf

		process@ ReparentChildren

		process@ ProcessFreeSlot

		process@ Process_CWDVNode + @ VNodeUnref

		auto ofile
		process@ Process_OFiles + ofile!

		while (i@ OFILEMAX <)
			if (ofile@@)
				ofile@@ FileP_VNode + @ VNodeUnref
				ofile@@ UnrefFilp
			end

			4 ofile +=
			1 i +=
		end
	end
end