#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/context.h"

table Threads[THREADMAX]
public Threads

table Processes[PROCMAX]
public Processes

var CurrentThread 0
public CurrentThread

var KernelProcess 0
public KernelProcess

var InitProcess 0

const KERNELPID 1

extern AISIXInitialThread

procedure ThreadInit { -- }
	PROCMAX THREADMAX "max %d threads, %d processes\n" Printf

	auto process
	pointerof AISIXInitialThread "kernel" ProcessNew process!

	if (process@ iserr KernelProcess@ process@ ~= ||)
		"couldn't set up kernel process\n" Panic
	end

	process@ Process_MainThread + @ ThreadReady
end

procedure private ThreadAllocate { -- thread }
	auto tid
	0 tid!

	-ENOMEM thread!

	while (tid@ THREADMAX <)
		Lock

		if ([tid@]Threads@ 0 ==)
			auto ts
			Thread_SIZEOF Calloc ts!

			if (ts@ iserr)
				Unlock
				ts@ thread!
				return
			end

			tid@ ts@ Thread_TID + !

			ts@ [tid@]Threads!

			Unlock
			ts@ thread!
			return
		end

		Unlock

		1 tid +=
	end
end

procedure private ThreadFreeSlot { thread -- }
	auto tid
	thread@ Thread_TID + @ tid!

	0 [tid@]Threads!

	thread@ Free
end

procedure ThreadFree { thread -- }
	KERNELSTACKPAGES thread@ Thread_KernelStack + @ PMMFree
	VALUESTACKPAGES thread@ Thread_ValueStack + @ PMMFree

	thread@ ThreadFreeSlot
end

procedure ThreadKill { thread -- }
	if (thread@ Thread_Status + @ TS_SLEEPING ~=)
		thread@ ThreadFree
	end else
		1 thread@ Thread_Killed + !
		TS_READY thread@ Thread_Status + !
	end
end

procedure ThreadExit { -- }
	auto thread
	CurrentThread@ thread!

	auto process
	thread@ Thread_Process + @ process!

	if (process@ Process_Threads + @ 1 ==)
		0 ProcessExit
	end else
		1 process@ Process_Threads + -=

		thread@ ThreadKill
	end

	JumpIntoScheduler
end

procedure ThreadNew { process entry name -- thread }
	ThreadAllocate thread!

	if (thread@ iserr)
		return
	end

	process@ thread@ Thread_Process + !

	auto stack
	KERNELSTACKPAGES PMMCalloc stack!

	if (stack@ iserr)
		thread@ ThreadFreeSlot
		stack@ thread!
		return
	end

	auto vs
	VALUESTACKPAGES PMMCalloc vs!

	if (vs@ iserr)
		KERNELSTACKPAGES stack@ PMMFree
		thread@ ThreadFreeSlot
		vs@ thread!
		return
	end

	stack@ thread@ Thread_KernelStack + !
	vs@ thread@ Thread_ValueStack + !

	auto uc

	auto vst

	KERNELSTACKPAGES 4096 * stack@ + dup thread@ Thread_KernelStackTop + ! uc!
	VALUESTACKPAGES 4096 * vs@ + dup thread@ Thread_ValueStackTop + ! vst!

	vst@ entry@ uc@ CPUContextPrepare thread@ Thread_Context + !

	thread@ Thread_Name + name@ THREADNAMELEN 1 - strncpy

	1 process@ Process_Threads + +=
end

procedure ThreadReady { thread -- }
	TS_READY thread@ Thread_Status + !
end

procedure KernelThreadNew { entry name -- thread }
	KernelProcess@ entry@ name@ ThreadNew thread!
end

extern cswtch

extern CPUIdle

var SchedulerContext 0

(* scheduler *)
procedure Scheduler { -- }
	"entering scheduler loop\n" Printf

	while (1)
		auto nthread
		ThreadPick nthread!

		if (nthread@ iserr)
			CPUIdle
		end else
			nthread@ CurrentThread!

			TS_RUNNING nthread@ Thread_Status + !

			SchedulerContext nthread@ Thread_Context + @ cswtch
		end
	end
end

procedure JumpIntoScheduler { -- }
	auto o
	auto l
	SaveLock l! o!

	CurrentThread@ Thread_Context + SchedulerContext@ cswtch

	o@ l@ RestoreLock
end

procedure ThreadPick { -- thread }
	CurrentThread@ thread!

	auto index
	0 index!

	if (thread@)
		thread@ Thread_TID + @ 1 + index!
	end

	auto i
	0 i!

	while (i@ THREADMAX <)
		[index@ THREADMAX %]Threads@ thread!

		if (thread@ 0 ~=)
			if (thread@ Thread_Status + @ TS_READY ==)
				return
			end
		end

		1 i +=
		1 index +=
	end

	-ESRCH thread!
end

procedure Yield { -- }
	TS_READY CurrentThread@ Thread_Status + !

	JumpIntoScheduler
end

procedure Sleep { channel -- killed }
	Lock

	channel@ CurrentThread@ Thread_WaitChan + !

	TS_SLEEPING CurrentThread@ Thread_Status + !

	JumpIntoScheduler

	Unlock

	CurrentThread@ Thread_Killed + @ killed!
end

procedure Wakeup { channel -- }
	auto i
	0 i!

	while (i@ THREADMAX <)
		Lock

		auto thr
		[i@]Threads@ thr!

		if (thr@)
			if (thr@ Thread_Status + @ TS_SLEEPING ==)
				if (thr@ Thread_WaitChan + @ channel@ ==)
					0 thr@ Thread_WaitChan + !
					TS_READY thr@ Thread_Status + !
				end
			end
		end

		Unlock

		1 i +=
	end
end

(* =========== process management =========== *)

var NextPID 1

procedure private ProcessAllocate { -- process }
	auto i
	0 i!

	if (NextPID@ 0xFFFFFFFF ==)
		"ProcessAllocate: ran out of PIDs, somebody redo this algorithm\n" Panic
	end

	-ENOMEM process!

	while (i@ PROCMAX <)
		Lock

		if ([i@]Processes@ 0 ==)
			auto ps
			Process_SIZEOF Calloc ps!

			if (ps@ iserr)
				Unlock
				ps@ process!
				return
			end

			i@ ps@ Process_Index + !

			NextPID@ ps@ Process_PID + !

			1 NextPID +=

			ps@ [i@]Processes!

			Unlock
			ps@ process!
			return
		end

		Unlock

		1 i +=
	end
end

procedure private ProcessFreeSlot { process -- }
	auto index
	process@ Process_Index + @ index!

	0 [index@]Processes!

	[index@]Processes@ Free
end

procedure ProcessNew { entry name -- process }
	ProcessAllocate process!

	if (process@ iserr)
		return
	end

	process@ Process_Name + name@ PROCNAMELEN 1 - strncpy

	auto kernel
	0 kernel!

	if (process@ Process_PID + @ KERNELPID ==)
		1 kernel!
	end

	if (CurrentThread@)
		auto parent
		CurrentThread@ Thread_Process + @ parent!

		parent@ process@ Process_Parent + !

		parent@ Process_UserID + @ dup
		process@ Process_UserID + !
		process@ Process_EUserID + !
	end

	auto mthread

	process@ entry@ "main" ThreadNew mthread!

	mthread@ process@ Process_MainThread + !

	if (mthread@ iserr)
		process@ ProcessFreeSlot
		mthread@ process!
		return
	end

	if (kernel@)
		process@ KernelProcess!
		1 kernel!
	end
end

procedure ProcessDestroyThreads { process -- }
	auto i
	0 i!

	while (i@ THREADMAX <)
		auto thread
		[i@]Threads@ thread!

		if (thread@)
			if (thread@ Thread_Process + @ process@ ==)
				thread@ ThreadKill

				1 process@ Process_Threads + -=
			end
		end

		1 i +=
	end

	if (process@ Process_Threads + @ 0 ~=)
		"ProcessDestroyThreads: process wasn't murdered hard enough\n" Panic
	end
end

procedure ProcessFreeResources { process -- }
	if (process@ Process_Threads + @ 0 >)
		"ProcessFreeResources: process still had extant threads\n" Panic
	end

	if (process@ Process_Mapped + @)
		process@ Process_TextPages + @ process@ Process_TextPhysical + @ PMMFree
		process@ Process_DataPages + @ process@ Process_DataPhysical + @ PMMFree
		process@ Process_BSSPages + @ process@ Process_BSSPhysical + @ PMMFree
	end

	(* don't free slot now, will be needed later *)
end

procedure ProcessExit { ret -- }
	auto process
	CurrentThread@ Thread_Process + @ process!

	if (process@ KernelProcess@ ==)
		"kernel process exited!\n" Panic
	end

	Lock

	ret@ process@ Process_ReturnValue + !

	process@ ProcessDestroyThreads

	process@ ProcessFreeResources

	(* do wait syscall stuff here *)

	auto i
	0 i!

	while (i@ PROCMAX <)
		auto child
		[i@]Processes@ child!

		if (child@ 0 ~=)
			if (child@ Process_Parent + @ process@ ==)
				InitProcess@ child@ Process_Parent + !

				(* additional bookkeeping is probably required *)
			end
		end

		1 i +=
	end

	Unlock
end