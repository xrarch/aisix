#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"

(* ported from ancient AISIX *)

var KHeapStart 0
var KHeapSize 0
public KHeapSize
public KHeapStart
var KHeapLast 0

var KHeapUsed 0
public KHeapUsed

const MAGIC 0xD8F77558
const BADMAGICF 0xACA7BAB1
const BADMAGICB 0xACA7BAB7

const FRACTION 40

const MINSIZE 32

const RESETLAST 64

var Allocations 0

struct KHeapHeader
	4 magic
	4 size
	4 last
	4 next
	4 allocated
	4 allocby
endstruct

fn HeapInit { -- }
	auto heapsizep
	Pages@ FRACTION / MINSIZE max heapsizep!

	heapsizep@ PMMAlloc KHeapStart!

	0 KHeapLast!

	heapsizep@ 4096 * KHeapSize!

	if (KHeapStart@ iserr)
		"couldn't allocate heap!\n" Panic
	end

	KHeapStart@ heapsizep@ 4096 * "heap is %d bytes at 0x%x\n" Printf

	KHeapSize@ KHeapStart@ KHeapHeader_size + !
	0 KHeapStart@ KHeapHeader_last + !
	0 KHeapStart@ KHeapHeader_allocated + !
	0 KHeapStart@ KHeapHeader_next + !

	MAGIC KHeapStart@ KHeapHeader_magic + !
end

extern GetSym { pc -- symbase symname }

fn HeapDumpBlock { ept -- }
	ept@ "\tptr: 0x%x\n" Printf

	auto size
	ept@ KHeapHeader_size + @ size!

	auto asz
	size@ KHeapHeader_SIZEOF - asz!

	auto alloct
	ept@ KHeapHeader_allocated + @ alloct!

	auto last
	ept@ KHeapHeader_last + @ last!

	auto magic
	ept@ KHeapHeader_magic + @ magic!

	auto next
	ept@ KHeapHeader_next + @ next!

	auto ab
	ept@ KHeapHeader_allocby + @ ab!

	size@ "\tsize: %d bytes\n" Printf
	asz@ "\treal size: %d bytes\n" Printf
	last@ "\tlast: 0x%x\n" Printf
	next@ "\tnext: 0x%x\n" Printf
	alloct@ "\tallocated: %d\n" Printf
	magic@ "\tmagic: %x\n" Printf

	auto symname
	ab@ GetSym swap drop symname!

	if (symname@ ~~)
		"UNKNOWN" symname!
	end

	symname@ "\tallocby: <%s>\n" Printf
end

fn HeapDump { -- }
	auto ept
	KHeapStart@ ept!

	auto max
	KHeapStart@ KHeapSize@ + max!

	auto tfree
	0 tfree!

	auto talloc
	0 talloc!

	auto i
	0 i!

	auto stotal
	0 stotal!

	while (ept@)
		if (ept@ 3 &)
			"unaligned block!\n" Printf
			break
		end

		auto size
		ept@ KHeapHeader_size + @ size!

		auto alloct
		ept@ KHeapHeader_allocated + @ alloct!

		i@ "block %d:\n" Printf

		ept@ HeapDumpBlock

		if (alloct@ 1 ==)
			talloc@ size@ + talloc!
		end else
			tfree@ size@ + tfree!
		end

		if (size@ 0 ==)
			"size 0, very weird, breaking\n" Printf
			break
		end

		stotal@ size@ + stotal!
		
		auto lept
		ept@ lept!
		ept@ KHeapHeader_next + @ ept!

		if (lept@ size@ + ept@ ~=)
			"DISPARITY!\n" Printf
		end

		1 i +=
	end

	tfree@ talloc@ stotal@ "heap size: 0x%x bytes.\n%d bytes taken, %d bytes free.\n" Printf
end

(* first-fit *)

fn Malloc1 { ac endp startp sz -- ptr }
	if (sz@ 0 ==)
		"Malloc: sz = 0\n" Panic
	end

	if (startp@ 0 ==)
		KHeapStart@ startp!
	end

	auto mysize
	sz@ KHeapHeader_SIZEOF + mysize!

	auto thissize

	startp@ ptr!

	while (ptr@ endp@ ~=)
		if (ptr@ 3 &)
			ptr@ "Malloc: unaligned block %x\n" Panic
		end

		if (ptr@ KHeapHeader_magic + @ MAGIC ~=)
			ptr@ ptr@ KHeapHeader_magic + @ "Malloc: bad magic %x on block %x\n" Panic
		end

		if (ptr@ KHeapHeader_allocated + @)
			ptr@ KHeapHeader_next + @ ptr!
			continue
		end

		ptr@ KHeapHeader_size + @ thissize!

		if (thissize@ mysize@ >=)
			auto be
			0 be!

			if (thissize@ mysize@ ==)
				1 be!
			end elseif (thissize@ mysize@ - KHeapHeader_SIZEOF <=)
				thissize@ mysize!
				1 be!
			end

			if (be@)
				break
			end

			(* split the block *)

			auto newsize
			thissize@ mysize@ - newsize!

			auto newblockp
			ptr@ mysize@ + newblockp!

			auto link
			ptr@ KHeapHeader_next + @ link!

			link@ newblockp@ KHeapHeader_next + !

			if (link@)
				newblockp@ link@ KHeapHeader_last + !
			end

			mysize@ ptr@ KHeapHeader_size + !
			newblockp@ ptr@ KHeapHeader_next + !

			MAGIC newblockp@ KHeapHeader_magic + !
			ptr@ newblockp@ KHeapHeader_last + !
			newsize@ newblockp@ KHeapHeader_size + !
			0 newblockp@ KHeapHeader_allocated + !

			break
		end

		ptr@ KHeapHeader_next + @ ptr!
	end

	if (ptr@ endp@ ==)
		-ENOMEM ptr!
		return
	end

	if (ptr@ iserr ~~)
		ptr@ KHeapLast!

		1 ptr@ KHeapHeader_allocated + !

		mysize@ KHeapUsed +=

		ac@ ptr@ KHeapHeader_allocby + !

		KHeapHeader_SIZEOF ptr +=
	end
end

asm "

GetAllocator:
	lio.l v0, sp, 4
	ret

"

extern GetAllocator { -- pc }

fn Malloc2 { ac size -- ptr }
	if (size@ 0 ==)
		"0 malloc\n" Panic
	end

	if (size@ 0x3 & 0 ~=)
		size@ 0xFFFFFFFC & 4 + size!
	end

	auto rs
	InterruptDisable rs!

	if (Allocations@ RESETLAST ==)
		0 KHeapLast!
		0 Allocations!
	end

	ac@ 0 KHeapLast@ size@ Malloc1 ptr!

	if (ptr@ iserr ~~)
		1 Allocations +=

		rs@ InterruptRestore

		return
	end

	ac@ KHeapLast@ 0 size@ Malloc1 ptr!

	if (ptr@ iserr ~~)
		1 Allocations +=

		rs@ InterruptRestore

		return
	end

	rs@ InterruptRestore

	-ENOMEM ptr! return
end

fn Malloc { size -- ptr }
	GetAllocator size@ Malloc2 ptr!
end

fn Calloc { size -- ptr }
	GetAllocator size@ Malloc2 ptr!

	if (ptr@ iserr)
		return
	end

	ptr@ size@ 0 memset
end

fn Free { ptr -- }
	if (ptr@ 0 == ptr@ iserr ||)
		ptr@ "tried to free 0x%x!\n" Panic
	end

	auto nptr
	ptr@ KHeapHeader_SIZEOF - nptr!

	if (nptr@ KHeapHeader_magic + @ MAGIC ~=)
		ptr@ nptr@ KHeapHeader_magic + @ "Free: bad magic %x on block 0x%x\n" Panic
	end

	auto rs
	InterruptDisable rs!

	if (nptr@ KHeapHeader_allocated + @ 1 ~=)
		ptr@ "tried to free block that was not allocated\n" Panic
	end

	nptr@ KHeapHeader_size + @ KHeapUsed -=

	0 nptr@ KHeapHeader_allocated + !

	auto link
	nptr@ KHeapHeader_next + @ link!

	if (link@)
		if (link@ KHeapHeader_allocated + @ 0 ==)
			link@ KHeapHeader_size + @ nptr@ KHeapHeader_size + +=

			link@ KHeapHeader_next + @ nptr@ KHeapHeader_next + !

			BADMAGICB link@ KHeapHeader_magic + !

			if (link@ KHeapLast@ ==)
				0 KHeapLast!
			end

			link@ KHeapHeader_next + @ link!

			if (link@)
				nptr@ link@ KHeapHeader_last + !
			end
		end
	end

	nptr@ KHeapHeader_last + @ link!

	auto tlink

	if (link@)
		if (link@ KHeapHeader_allocated + @ 0 ==)
			nptr@ KHeapHeader_size + @ link@ KHeapHeader_size + +=

			nptr@ KHeapHeader_next + @ link@ KHeapHeader_next + !

			BADMAGICF nptr@ KHeapHeader_magic + !

			nptr@ KHeapHeader_next + @ tlink!

			if (tlink@)
				link@ tlink@ KHeapHeader_last + !
			end

			if (nptr@ KHeapLast@ ==)
				0 KHeapLast!
			end
		end
	end

	rs@ InterruptRestore
end