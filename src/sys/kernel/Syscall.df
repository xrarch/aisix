#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/context.h"

table Syscalls
	0
	pointerof SysOpen
	pointerof SysWrite
	pointerof SysClose
	pointerof SysRead
	pointerof SysNewProcess
	pointerof SysExit
	pointerof SysDup
	pointerof SysSetTTYIgnore
	pointerof SysWait
	pointerof SysSetUID
	pointerof SysGetPID
	pointerof SysGetUID
	pointerof SysGetEUID
	pointerof SysReadDir
	pointerof SysPStat
	pointerof SysFStat
	pointerof SysChdir
	pointerof SysUnlink
	pointerof SysUName
	pointerof SysMkdir
	pointerof SysUMask
	pointerof SysMount
	pointerof SysUMount
	pointerof SysChown
	pointerof SysChmod
	pointerof SysSync
endtable
public Syscalls

fn private GetString { user len -- str }
	if (user@ ~~)
		-EINVAL str!
		return
	end

	auto r
	len@ user@ 0 PlatformUserToPhys r! user!

	if (r@ ~~)
		-EINVAL str!
		return
	end

	len@ 1 + Calloc str!

	if (str@ iserr)
		return
	end

	str@ user@ len@ strncpy
end

fn (Syscall) SysOpen { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto mode
	tf@ Context_a3 + @ mode!

	auto pbits
	tf@ Context_v0 + @ pbits!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ mode@ pbits@ Open ok!

	path@ Free
end

fn (Syscall) SysWrite { tf -- ok }
	auto buf
	tf@ Context_a3 + @ buf!

	auto len
	tf@ Context_a2 + @ len!

	auto fd
	tf@ Context_a1 + @ fd!

	auto r
	len@ buf@ 0 PlatformUserToPhys r! buf!

	if (r@ ~~)
		-EINVAL ok!
		return
	end

	buf@ len@ fd@ Write ok!
end

fn (Syscall) SysClose { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	fd@ Close ok!
end

fn (Syscall) SysRead { tf -- ok }
	auto buf
	tf@ Context_a3 + @ buf!

	auto len
	tf@ Context_a2 + @ len!

	auto fd
	tf@ Context_a1 + @ fd!

	auto r
	len@ buf@ 1 PlatformUserToPhys r! buf!

	if (r@ ~~)
		-EINVAL ok!
		return
	end

	buf@ len@ fd@ Read ok!
end

fn private GetKVec { udc udv -- kdv }
	0 kdv!

	auto p1
	auto p2
	auto r

	if (udc@)
		udc@ UDVec_SIZEOF * udv@ 1 PlatformUserToPhys r! udv!

		if (r@ ~~)
			-EINVAL kdv!
			return
		end

		udc@ UDVec_SIZEOF * Malloc kdv!

		if (kdv@ iserr)
			-ENOMEM kdv!
			return
		end

		auto i
		0 i!

		kdv@ p1!

		while (i@ udc@ <)
			if (udv@ UDVec_Size + @ 0 ==)
				0 p1@ UDVec_Size + !
				0 p1@ UDVec_Ptr + !

				1 i +=
				UDVec_SIZEOF p1 +=
				UDVec_SIZEOF udv +=
				continue
			end

			udv@ UDVec_Size + @ udv@ UDVec_Ptr + @ 0 PlatformUserToPhys r! p2!

			if (r@ ~~)
				kdv@ Free
				-EINVAL kdv!
				return
			end

			udv@ UDVec_Size + @ p1@ UDVec_Size + !
			p2@ p1@ UDVec_Ptr + !

			UDVec_SIZEOF p1 +=
			UDVec_SIZEOF udv +=
			1 i +=
		end
	end
end

fn (Syscall) SysNewProcess { tf -- ok }
	auto udc
	tf@ Context_a1 + @ udc!

	auto udv
	tf@ Context_a2 + @ udv!

	auto mode
	tf@ Context_a3 + @ mode!

	auto fd2
	tf@ Context_v0 + @ fd2!

	auto fd1
	tf@ Context_v1 + @ fd1!

	auto fd0
	tf@ Context_t0 + @ fd0!

	auto path
	tf@ Context_t1 + @ path!

	if (mode@ NP_SPECIFY >)
		-EINVAL ok!
		return
	end

	if (udv@ 3 &)
		-EINVAL ok!
		return
	end

	auto kdv
	udc@ udv@ GetKVec kdv!

	if (kdv@ iserr)
		kdv@ ok!
		return
	end

	path@ tf@ Context_t2 + @ GetString path!

	if (path@ iserr)
		path@ ok!
		if (kdv@)
			kdv@ Free
		end
		return
	end

	auto vnode
	path@ VFSPath vnode!

	if (vnode@ iserr)
		path@ Free
		if (kdv@)
			kdv@ Free
		end
		vnode@ ok!
		return
	end

	if (mode@ NP_SPECIFY ==)
		if (fd0@ -1 ==)
			0 fd0!
		end else
			fd0@ GetFilp fd0!
			if (fd0@ iserr)
				fd0@ ok!
				path@ Free
				vnode@ VNodePut
				if (kdv@)
					kdv@ Free
				end
				return
			end
		end

		if (fd1@ -1 ==)
			0 fd1!
		end else
			fd1@ GetFilp fd1!
			if (fd1@ iserr)
				fd1@ ok!
				path@ Free
				vnode@ VNodePut
				if (kdv@)
					kdv@ Free
				end
				return
			end
		end

		if (fd2@ -1 ==)
			0 fd2!
		end else
			fd2@ GetFilp fd2!
			if (fd2@ iserr)
				fd2@ ok!
				path@ Free
				vnode@ VNodePut
				if (kdv@)
					kdv@ Free
				end
				return
			end
		end
	end

	auto proc

	vnode@ VNodeUnlock

	vnode@ path@ fd0@ fd1@ fd2@ mode@ kdv@ udc@ VNewProcess proc!

	vnode@ VNodeUnref

	path@ Free

	if (kdv@)
		kdv@ Free
	end

	if (proc@ iserr)
		proc@ ok!
		return
	end

	proc@ Process_PID + @ ok!
end

fn (Syscall) SysExit { tf -- ok }
	auto ret
	tf@ Context_a1 + @ ret!

	ret@ ProcessExit

	0 ok!
end

fn (Syscall) SysDup { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	fd@ FilDup ok!
end

fn (Syscall) SysSetTTYIgnore { tf -- ok }
	auto ttyign
	tf@ Context_a1 + @ ttyign!

	if (ttyign@ 0xFF & 1 >)
		-EINVAL ok!
		return
	end

	if (ttyign@ 8 >> 3 >=)
		-EINVAL ok!
		return
	end

	ttyign@ CurrentThread@ Thread_Process + @ Process_IgnoreTTY + !
end

(* ret ends up in v1, pid ends up in v0 *)
fn (Syscall) SysWait { tf -- ok }
	Wait tf@ Context_v1 + ! ok!
end

fn (Syscall) SysSetUID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	auto tuid
	tf@ Context_a1 + @ tuid!

	0 ok!

	if (p@ Process_UID + @ tuid@ ==)
		tuid@ p@ Process_EUID + !
	end elseif (p@ Process_EUID + @ tuid@ ==)
		tuid@ p@ Process_UID + !
	end elseif (p@ Process_EUID + @ 0 ==) (* root can do whatever she wants *)
		tuid@ p@ Process_UID + !
		tuid@ p@ Process_EUID + !
	end else
		-EPERM ok!
	end
end

fn (Syscall) SysGetPID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	p@ Process_PID + @ ok!
end

fn (Syscall) SysGetUID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	p@ Process_UID + @ ok!
end

fn (Syscall) SysGetEUID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	p@ Process_EUID + @ ok!
end

fn (Syscall) SysReadDir { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	auto dirent
	tf@ Context_a2 + @ dirent!

	auto r
	Dirent_SIZEOF dirent@ 1 PlatformUserToPhys r! dirent!

	if (r@ ~~)
		-EINVAL ok!
		return
	end

	dirent@ fd@ ReadDir ok!
end

fn (Syscall) SysPStat { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto stat
	tf@ Context_a2 + @ stat!

	auto pathlen
	tf@ Context_a3 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	auto r
	Stat_SIZEOF stat@ 1 PlatformUserToPhys r! stat!

	if (r@ ~~)
		path@ Free
		-EINVAL ok!
		return
	end

	stat@ path@ PStat ok!

	path@ Free
end

fn (Syscall) SysFStat { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	auto stat
	tf@ Context_a2 + @ stat!

	auto r
	Stat_SIZEOF stat@ 1 PlatformUserToPhys r! stat!

	if (r@ ~~)
		-EINVAL ok!
		return
	end

	stat@ fd@ FStat ok!
end

fn (Syscall) SysChdir { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ Chdir ok!

	path@ Free
end

fn (Syscall) SysUnlink { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ Unlink ok!

	path@ Free
end

struct UNameS
	256 Sysname
	256 Nodename
	256 Release
	256 Version
	256 Machine
	256 Processor
endstruct

asm "

.section data

_date:
	.ds$ __DATE
	.db 0

.align 4

.section text

"

fn (Syscall) SysUName { tf -- ok }
	auto uname
	tf@ Context_a1 + @ uname!

	auto r
	UNameS_SIZEOF uname@ 1 PlatformUserToPhys r! uname!

	if (r@ ~~)
		-EINVAL ok!
		return
	end

	uname@ UNameS_Sysname +  "AISIX" strcpy
	uname@ UNameS_Nodename + "unk" strcpy
	uname@ UNameS_Release +  "unk" strcpy

	auto vstr
	"pre-1.0 " vstr!

	auto vl
	vstr@ strlen vl!

	uname@ UNameS_Version + vstr@ strcpy
	
	uname@ UNameS_Version + vl@ +
	pointerof _date
	255 vl@ - strncpy
	
	uname@ UNameS_Machine + MachineType@ 255 strncpy
	uname@ UNameS_Processor + MachineCPU@ 255 strncpy

	0 ok!
end

fn (Syscall) SysMkdir { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto mode
	tf@ Context_a3 + @ mode!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ mode@ Mkdir ok!

	path@ Free
end

fn (Syscall) SysUMask { tf -- ok }
	auto umask
	tf@ Context_a1 + @ umask!

	CurrentThread@ Thread_Process + @ Process_UMask + @ ok!

	umask@ CurrentThread@ Thread_Process + @ Process_UMask + !
end

fn (Syscall) SysMount { tf -- ok }
	if (CurrentThread@ Thread_Process + @ Process_EUID + @ 0 ~=)
		-EPERM ok!
		return
	end

	auto type
	tf@ Context_a1 + @ type!

	auto typelen
	tf@ Context_a2 + @ typelen!

	type@ typelen@ GetString type!

	if (type@ iserr)
		type@ ok!
		return
	end

	auto dir
	tf@ Context_a3 + @ dir!

	auto dirlen
	tf@ Context_v0 + @ dirlen!

	dir@ dirlen@ GetString dir!

	if (dir@ iserr)
		type@ Free
		dir@ ok!
		return
	end

	auto pdev
	tf@ Context_v1 + @ pdev!

	auto pdevlen
	tf@ Context_t0 + @ pdevlen!

	if (pdev@)
		pdev@ pdevlen@ GetString pdev!

		if (pdev@ iserr)
			type@ Free
			dir@ Free
			pdev@ ok!
			return
		end
	end

	auto flags
	tf@ Context_t1 + @ flags!

	type@ dir@ pdev@ flags@ SMount ok!

	type@ Free

	dir@ Free

	if (pdev@)
		pdev@ Free
	end
end

fn (Syscall) SysUMount { tf -- ok }
	if (CurrentThread@ Thread_Process + @ Process_EUID + @ 0 ~=)
		-EPERM ok!
		return
	end

	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ UMount ok!

	path@ Free
end

fn (Syscall) SysChown { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto owner
	tf@ Context_a3 + @ owner!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ owner@ Chown ok!

	path@ Free
end

fn (Syscall) SysChmod { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto mode
	tf@ Context_a3 + @ mode!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ mode@ Chmod ok!

	path@ Free
end

fn (Syscall) SysSync { tf -- ok }
	VFSSync ok!
end