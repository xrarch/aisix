#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/context.h"

table Syscalls
	0
	pointerof SysOpen
	pointerof SysWrite
	pointerof SysClose
	pointerof SysRead
	pointerof SysNewProcess
	pointerof SysExit
	pointerof SysDup
	pointerof SysSetTTYIgnore
	pointerof SysWait
	pointerof SysSetUID
	pointerof SysGetPID
	pointerof SysGetUID
	pointerof SysGetEUID
	pointerof SysReadDir
	pointerof SysPStat
	pointerof SysFStat
	pointerof SysChdir
	pointerof SysUnlink
	pointerof SysUName
	pointerof SysMkdir
	pointerof SysUMask
	pointerof SysMount
	pointerof SysUMount
	pointerof SysChown
	pointerof SysChmod
	pointerof SysSync
	pointerof SysSeek
	pointerof SysGetCWD
	pointerof SysHalt
endtable
public Syscalls

const STRMAX 256

fn private GetString { user len -- str }
	if (user@ ~~)
		-EINVAL str!
		return
	end

	if (len@ STRMAX >=)
		-E2BIG str!
		return
	end

	auto p
	CurrentThread@ Thread_Process + @ Process_Pagemap + @ p!

	len@ 1 + Calloc str!

	if (str@ iserr)
		return
	end

	auto ok
	p@ str@ user@ len@ VMStrnCopyin ok!

	if (ok@ iserr)
		str@ Free
		ok@ str!
	end
end

fn (Syscall) SysOpen { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto mode
	tf@ Context_a3 + @ mode!

	auto pbits
	tf@ Context_v0 + @ pbits!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ mode@ pbits@ Open ok!

	path@ Free
end

fn (Syscall) SysWrite { tf -- ok }
	auto buf
	tf@ Context_a3 + @ buf!

	auto len
	tf@ Context_a2 + @ len!

	auto fd
	tf@ Context_a1 + @ fd!

	buf@ len@ fd@ Write ok!
end

fn (Syscall) SysClose { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	fd@ Close ok!
end

fn (Syscall) SysRead { tf -- ok }
	auto buf
	tf@ Context_a3 + @ buf!

	auto len
	tf@ Context_a2 + @ len!

	auto fd
	tf@ Context_a1 + @ fd!

	buf@ len@ fd@ Read ok!
end

fn (Syscall) SysNewProcess { tf -- ok }
	auto udc
	tf@ Context_a1 + @ udc!

	auto udv
	tf@ Context_a2 + @ udv!

	auto mode
	tf@ Context_a3 + @ mode!

	auto fd2
	tf@ Context_v0 + @ fd2!

	auto fd1
	tf@ Context_v1 + @ fd1!

	auto fd0
	tf@ Context_t0 + @ fd0!

	auto path
	tf@ Context_t1 + @ path!

	if (mode@ NP_SPECIFY >)
		-EINVAL ok!
		return
	end

	if (udc@ 64 >)
		-E2BIG ok!
		return
	end

	if (udv@ 3 &)
		-EINVAL ok!
		return
	end

	path@ tf@ Context_t2 + @ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	if (udc@)
		auto udvs
		udc@ UDVec_SIZEOF * udvs!

		auto kdv
		udvs@ Malloc kdv!

		if (kdv@ iserr)
			path@ Free
			return
		end

		CurrentThread@ Thread_Process + @ Process_Pagemap + @ kdv@ udv@ udvs@ VMCopyin ok!

		if (ok@ iserr)
			path@ Free
			kdv@ Free
			return
		end
	end

	auto vnode
	path@ VFSPath vnode!

	if (vnode@ iserr)
		if (udc@)
			kdv@ Free
		end
		path@ Free
		vnode@ ok!
		return
	end

	if (mode@ NP_SPECIFY ==)
		if (fd0@ -1 ==)
			0 fd0!
		end else
			fd0@ GetFilp fd0!
			if (fd0@ iserr)
				if (udc@)
					kdv@ Free
				end
				fd0@ ok!
				path@ Free
				vnode@ VNodePut
				return
			end
		end

		if (fd1@ -1 ==)
			0 fd1!
		end else
			fd1@ GetFilp fd1!
			if (fd1@ iserr)
				if (udc@)
					kdv@ Free
				end
				fd1@ ok!
				path@ Free
				vnode@ VNodePut
				return
			end
		end

		if (fd2@ -1 ==)
			0 fd2!
		end else
			fd2@ GetFilp fd2!
			if (fd2@ iserr)
				if (udc@)
					kdv@ Free
				end
				fd2@ ok!
				path@ Free
				vnode@ VNodePut
				return
			end
		end
	end

	auto proc

	vnode@ VNodeUnlock

	vnode@ path@ fd0@ fd1@ fd2@ mode@ kdv@ udc@ VNewProcess proc!

	vnode@ VNodeUnref

	path@ Free

	if (udc@)
		kdv@ Free
	end

	if (proc@ iserr)
		proc@ ok!
		return
	end

	proc@ Process_PID + @ ok!
end

fn (Syscall) SysExit { tf -- ok }
	auto ret
	tf@ Context_a1 + @ ret!

	ret@ ProcessExit

	0 ok!
end

fn (Syscall) SysDup { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	fd@ FilDup ok!
end

fn (Syscall) SysSetTTYIgnore { tf -- ok }
	auto ttyign
	tf@ Context_a1 + @ ttyign!

	if (ttyign@ 0xFF & 1 >)
		-EINVAL ok!
		return
	end

	if (ttyign@ 8 >> 3 >=)
		-EINVAL ok!
		return
	end

	ttyign@ CurrentThread@ Thread_Process + @ Process_IgnoreTTY + !
end

(* ret ends up in v1, pid ends up in v0 *)
fn (Syscall) SysWait { tf -- ok }
	Wait tf@ Context_v1 + ! ok!
end

fn (Syscall) SysSetUID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	auto tuid
	tf@ Context_a1 + @ tuid!

	0 ok!

	if (p@ Process_UID + @ tuid@ ==)
		tuid@ p@ Process_EUID + !
	end elseif (p@ Process_EUID + @ tuid@ ==)
		tuid@ p@ Process_UID + !
	end elseif (p@ Process_EUID + @ 0 ==) (* root can do whatever she wants *)
		tuid@ p@ Process_UID + !
		tuid@ p@ Process_EUID + !
	end else
		-EPERM ok!
	end
end

fn (Syscall) SysGetPID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	p@ Process_PID + @ ok!
end

fn (Syscall) SysGetUID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	p@ Process_UID + @ ok!
end

fn (Syscall) SysGetEUID { tf -- ok }
	auto p
	CurrentThread@ Thread_Process + @ p!

	p@ Process_EUID + @ ok!
end

fn (Syscall) SysReadDir { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	auto udirent
	tf@ Context_a2 + @ udirent!

	auto dirent
	Dirent_SIZEOF Malloc dirent!

	if (dirent@ iserr)
		dirent@ ok!
		return
	end

	dirent@ fd@ ReadDir ok!

	if (ok@ iserr)
		dirent@ Free
		return
	end

	CurrentThread@ Thread_Process + @ Process_Pagemap + @ udirent@ dirent@ Dirent_SIZEOF VMCopyout ok!

	dirent@ Free
end

fn (Syscall) SysPStat { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto ustat
	tf@ Context_a2 + @ ustat!

	if (ustat@ 3 &)
		-EINVAL ok!
		return
	end

	auto pathlen
	tf@ Context_a3 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	auto stat
	Stat_SIZEOF Malloc stat!

	if (stat@ iserr)
		stat@ ok!
		return
	end

	stat@ path@ PStat ok!

	path@ Free

	if (ok@ iserr)
		stat@ Free
		return
	end

	CurrentThread@ Thread_Process + @ Process_Pagemap + @ ustat@ stat@ Stat_SIZEOF VMCopyout ok!

	stat@ Free
end

fn (Syscall) SysFStat { tf -- ok }
	auto fd
	tf@ Context_a1 + @ fd!

	auto ustat
	tf@ Context_a2 + @ ustat!

	if (ustat@ 3 &)
		-EINVAL ok!
		return
	end

	auto stat
	Stat_SIZEOF Malloc stat!

	if (stat@ iserr)
		stat@ ok!
		return
	end

	stat@ fd@ FStat ok!

	if (ok@ iserr)
		stat@ Free
		return
	end

	CurrentThread@ Thread_Process + @ Process_Pagemap + @ ustat@ stat@ Stat_SIZEOF VMCopyout ok!

	stat@ Free
end

fn (Syscall) SysChdir { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ Chdir ok!

	path@ Free
end

fn (Syscall) SysUnlink { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ Unlink ok!

	path@ Free
end

struct UNameS
	256 Sysname
	256 Nodename
	256 Release
	256 Version
	256 Machine
	256 Processor
endstruct

asm "

.section data

_date:
	.ds$ __DATE
	.db 0

.align 4

.section text

"

fn (Syscall) SysUName { tf -- ok }
	auto uname
	tf@ Context_a1 + @ uname!

	auto kuname
	UNameS_SIZEOF Calloc kuname!

	if (kuname@ iserr)
		kuname@ ok!
		return
	end

	kuname@ UNameS_Sysname +  "AISIX" strcpy
	kuname@ UNameS_Nodename + "unk" strcpy
	kuname@ UNameS_Release +  "unk" strcpy

	auto vstr
	"pre-1.0 " vstr!

	auto vl
	vstr@ strlen vl!

	kuname@ UNameS_Version + vstr@ strcpy
	
	kuname@ UNameS_Version + vl@ +
	pointerof _date
	255 vl@ - strncpy
	
	kuname@ UNameS_Machine + MachineType@ 255 strncpy
	kuname@ UNameS_Processor + MachineCPU@ 255 strncpy

	CurrentThread@ Thread_Process + @ Process_Pagemap + @ uname@ kuname@ UNameS_SIZEOF VMCopyout ok!
end

fn (Syscall) SysMkdir { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto mode
	tf@ Context_a3 + @ mode!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ mode@ Mkdir ok!

	path@ Free
end

fn (Syscall) SysUMask { tf -- ok }
	auto umask
	tf@ Context_a1 + @ umask!

	CurrentThread@ Thread_Process + @ Process_UMask + @ ok!

	umask@ CurrentThread@ Thread_Process + @ Process_UMask + !
end

fn (Syscall) SysMount { tf -- ok }
	if (CurrentThread@ Thread_Process + @ Process_EUID + @ 0 ~=)
		-EPERM ok!
		return
	end

	auto type
	tf@ Context_a1 + @ type!

	auto typelen
	tf@ Context_a2 + @ typelen!

	type@ typelen@ GetString type!

	if (type@ iserr)
		type@ ok!
		return
	end

	auto dir
	tf@ Context_a3 + @ dir!

	auto dirlen
	tf@ Context_v0 + @ dirlen!

	dir@ dirlen@ GetString dir!

	if (dir@ iserr)
		type@ Free
		dir@ ok!
		return
	end

	auto pdev
	tf@ Context_v1 + @ pdev!

	auto pdevlen
	tf@ Context_t0 + @ pdevlen!

	if (pdev@)
		pdev@ pdevlen@ GetString pdev!

		if (pdev@ iserr)
			type@ Free
			dir@ Free
			pdev@ ok!
			return
		end
	end

	auto flags
	tf@ Context_t1 + @ flags!

	type@ dir@ pdev@ flags@ SMount ok!

	type@ Free

	dir@ Free

	if (pdev@)
		pdev@ Free
	end
end

fn (Syscall) SysUMount { tf -- ok }
	if (CurrentThread@ Thread_Process + @ Process_EUID + @ 0 ~=)
		-EPERM ok!
		return
	end

	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ UMount ok!

	path@ Free
end

fn (Syscall) SysChown { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto owner
	tf@ Context_a3 + @ owner!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ owner@ Chown ok!

	path@ Free
end

fn (Syscall) SysChmod { tf -- ok }
	auto path
	tf@ Context_a1 + @ path!

	auto pathlen
	tf@ Context_a2 + @ pathlen!

	auto mode
	tf@ Context_a3 + @ mode!

	path@ pathlen@ GetString path!

	if (path@ iserr)
		path@ ok!
		return
	end

	path@ mode@ Chmod ok!

	path@ Free
end

fn (Syscall) SysSync { tf -- ok }
	VFSSync ok!
end

fn (Syscall) SysSeek { tf -- ok }
	auto whence
	tf@ Context_a1 + @ whence!

	auto offset
	tf@ Context_a2 + @ offset!

	auto fd
	tf@ Context_a3 + @ fd!

	fd@ offset@ whence@ Seek ok!
end

fn (Syscall) SysGetCWD { tf -- ok }
	auto buf
	tf@ Context_a1 + @ buf!

	auto p
	CurrentThread@ Thread_Process + @ p!

	auto cwdlen
	p@ Process_CWDPathString + strlen 1 + cwdlen!

	p@ Process_Pagemap + @ buf@ p@ Process_CWDPathString + cwdlen@ VMCopyout ok!
end

fn (Syscall) SysHalt { tf -- ok }
	auto hmode
	tf@ Context_a1 + @ hmode!

	hmode@ Halt ok!
end