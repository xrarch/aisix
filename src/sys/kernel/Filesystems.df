#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"

const Filesystems 2

externptr AISIXFSTab

table FilesystemTab
	pointerof DevFSTab
	pointerof AISIXFSTab
endtable

var MountListHead 0

var Mounted 0

var DevMount 0

var RootVNode 0
public RootVNode

buffer MountListMutex Mutex_SIZEOF

fn LockMountList { -- killed }
	MountListMutex LockMutex killed!
end

fn UnlockMountList { -- }
	MountListMutex UnlockMutex
end

fn MountRef { mount -- }
	auto rs
	InterruptDisable rs!

	1 mount@ Mount_MRefs + +=

	rs@ InterruptRestore
end

fn MountUnref { mount -- }
	auto rs
	InterruptDisable rs!

	if (mount@ Mount_MRefs + @ 0 ==)
		"MountUnref\n" Panic
	end

	1 mount@ Mount_MRefs + -=

	rs@ InterruptRestore
end

fn VFSInit { -- }
	"mount list" MountListMutex InitMutex

	auto syncw
	pointerof VFSSyncWorker "sync" KernelThreadNew syncw!

	if (syncw@ iserr)
		syncw@ abs syncw!
		[syncw@]ErrorNames@ "couldn't start sync worker: %s\n" Panic
	end

	syncw@ ThreadReady
end

var rn 0

fn VFSMountRoot { -- }
	if (RootDevice@ ~~)
		"couldn't find root device!\n" Panic
	end

	auto rootmount

	0 0 "aisixfs" FSByName RootDevice@ VFSMount rootmount!

	if (rootmount@ iserr)
		rootmount@ abs rootmount!
		[rootmount@]ErrorNames@ "couldn't mount root: %s\n" Panic
	end

	rootmount@ Mount_Root + @ RootVNode!

	RootVNode@ VNodeRef

	RootVNode@ KernelProcess@ Process_CWDVNode + !

	0 "/dev" "devfs" FSByName 0 VFSMount DevMount!

	if (DevMount@ iserr)
		DevMount@ abs DevMount!
		[DevMount@]ErrorNames@ "couldn't mount devfs: %s\n" Panic
	end
end

fn VRead { buf len seek vnode -- bytes }
	buf@ len@ seek@ vnode@ vnode@ VNode_Mount + @ Mount_Filesystem + @ Filesystem_Read + @ FSRead bytes!
end

fn VWrite { buf len seek vnode -- bytes }
	buf@ len@ seek@ vnode@ vnode@ VNode_Mount + @ Mount_Filesystem + @ Filesystem_Write + @ FSWrite bytes!
end

fn VTrunc { vnode -- ok }
	vnode@ vnode@ VNode_Mount + @ Mount_Filesystem + @ Filesystem_Trunc + @ FSTrunc ok!
end

fn VFSPath { path -- vnode }
	auto name
	auto dirvnode
	path@ VFSPathX name! vnode! dirvnode! drop

	if (name@)
		name@ Free
	end

	if (dirvnode@)
		dirvnode@ VNodePut
	end
end

fn VFSPathX { path -- sook dirvnode vnode name }
	0 name!
	0 dirvnode!

	if (path@ gb 0 ==)
		-ENOENT vnode!
		return
	end elseif (path@ gb '/' ==)
		RootVNode@ vnode!
	end else
		CurrentThread@ Thread_Process + @ Process_CWDVNode + @ vnode!
	end

	if (vnode@ VNodeLock)
		-EINTR vnode!
		return
	end

	vnode@ VNodeRef

	auto pcomp
	256 Malloc pcomp!

	auto pr

	auto dirent
	VDirent_SIZEOF Calloc dirent!

	auto mount
	vnode@ VNode_Mount + @ mount!

	auto fs
	mount@ Mount_Filesystem + @ fs!

	auto uid
	CurrentThread@ Thread_Process + @ Process_EUID + @ uid!

	auto ok

	while (1)
		0 sook!

		vnode@ VNode_Type + @ ok!

		if (path@ gb '/' ==)
			if (ok@ VNODE_DIR ~=)
				vnode@ VNodePut
				pcomp@ Free
				dirent@ Free
				-ENOTDIR vnode!
				return
			end

			while (path@ gb '/' ==)
				1 path +=
			end
		end

		if (path@ gb 0 ==)
			1 sook!
			(* finished *)
			pcomp@ name!
			dirent@ Free
			return
		end

		vnode@ WORLD_X uid@ VForbidden pr!

		if (pr@ iserr)
			vnode@ VNodePut
			pcomp@ Free
			dirent@ Free
			pr@ vnode!
			return
		end

		0 pr!

		while (1)
			if (path@ gb '/' == path@ gb 0 == ||)
				break
			end

			if (pr@ 256 <)
				path@ gb pcomp@ pr@ + sb
				1 pr +=
			end

			1 path +=
		end

		0 pcomp@ pr@ + sb

		if (pcomp@ "." strcmp)
			continue
		end

		path@ pr!

		while (pr@ gb '/' ==)
			1 pr +=
		end

		if (pr@ gb 0 ==)
			1 sook!
		end

		vnode@ dirent@ VDirent_DirVNode + !

		dirent@ fs@ Filesystem_RewindDir + @ FSRewindDir ok!

		if (ok@ iserr)
			vnode@ VNodePut
			pcomp@ Free
			dirent@ Free
			ok@ vnode!
			return
		end

		while (1)
			if (dirent@ VDirent_Cookie + @)
				dirent@ VDirent_Cookie + @ Free
				0 dirent@ VDirent_Cookie + !
			end

			dirent@ fs@ Filesystem_ReadDir + @ FSReadDir ok!

			if (ok@ iserr)
				if (dirvnode@)
					dirvnode@ VNodePut
				end

				vnode@ dirvnode!
				pcomp@ name!
				dirent@ Free
				ok@ vnode!
				return
			end

			if (dirent@ VDirent_Name + @ pcomp@ strcmp)
				if (dirvnode@)
					dirvnode@ VNodePut
				end

				if (vnode@ VNode_VNID + @ dirent@ VDirent_VNID + @ ==)
					vnode@ VNodePut
				end else
					vnode@ dirvnode!
				end

				dirent@ VDirent_VNID + @ mount@ VNodeGet ok!

				if (dirent@ VDirent_Cookie + @)
					dirent@ VDirent_Cookie + @ Free
					0 dirent@ VDirent_Cookie + !
				end

				ok@ vnode!

				if (ok@ iserr)
					pcomp@ Free
					dirent@ Free
					return
				end

				break
			end
		end

		if (dirent@ VDirent_Cookie + @)
			dirent@ VDirent_Cookie + @ Free
			0 dirent@ VDirent_Cookie + !
		end

		if (vnode@ VNode_CoveredBy + @)
			vnode@ VNode_CoveredBy + @ ok!
			vnode@ VNodePut
			ok@ vnode!
			vnode@ VNode_Mount + @ mount!
			mount@ Mount_Filesystem + @ fs!

			if (vnode@ VNodeLock)
				-EINTR vnode!
				pcomp@ Free
				dirent@ Free
				return
			end

			vnode@ VNodeRef

			if (dirvnode@)
				dirvnode@ VNodePut
			end

			0 dirvnode!
		end
	end
end

fn FSByName { name -- fs }
	auto i
	while (i@ Filesystems <)
		[i@]FilesystemTab@ fs!

		if (fs@ Filesystem_Name + @ name@ strcmp)
			return
		end

		1 i +=
	end

	0 fs!
end

fn VFSMount { flags path fs dev -- mount }
	if (fs@ 0 ==)
		"VFSMount: fs = 0\n" Panic
	end

	if (LockMountList)
		-EINTR mount!
		return
	end

	auto covervn
	0 covervn!

	if (path@)
		path@ VFSPath covervn!

		if (covervn@ iserr)
			covervn@ mount!
			return
		end

		if (covervn@ VNode_CoveredBy + @)
			covervn@ VNodePut

			-EBUSY mount!
			return
		end

		if (covervn@ VNode_Type + @ VNODE_DIR ~=)
			covervn@ VNodePut

			-ENOTDIR mount!
			return
		end
	end else
		if (RootVNode@)
			"mounting root twice?\n" Panic
		end
	end

	Mount_SIZEOF Calloc mount!

	if (mount@ iserr)
		UnlockMountList
		if (covervn@)
			covervn@ VNodePut
		end
		-ENOMEM mount!
		return
	end

	flags@ mount@ Mount_Flags + !

	auto rs

	if (dev@)
		InterruptDisable rs!

		if (dev@ Device_Mount + @ 0 ~=)
			rs@ InterruptRestore
			UnlockMountList
			mount@ Free
			if (covervn@)
				covervn@ VNodePut
			end
			-EBUSY mount!
			return
		end

		mount@ dev@ Device_Mount + !

		rs@ InterruptRestore
	end

	auto fsdata
	auto root

	fs@ mount@ Mount_Filesystem + !

	dev@ mount@ Mount_Device + !

	auto pname
	if (path@)
		path@ pname!
	end else
		"/" pname!
	end

	mount@ Mount_Path + pname@ MOUNTNAMELEN 1 - strncpy

	mount@ fs@ Filesystem_Mount + @ FSMount root!

	if (root@ iserr)
		mount@ Free
		root@ mount!
		0 dev@ Device_Mount + !
		UnlockMountList
		if (covervn@)
			covervn@ VNodePut
		end
		return
	end

	root@ mount@ Mount_Root + !

	if (covervn@)
		root@ covervn@ VNode_CoveredBy + !

		covervn@ mount@ Mount_Covering + !

		covervn@ VNodeUnlock
	end

	root@ VNodeUnlock 

	if (MountListHead@)
		MountListHead@ mount@ Mount_Next + !
		mount@ MountListHead@ Mount_Prev + !
	end

	mount@ MountListHead!

	1 Mounted +=

	UnlockMountList

	auto devname
	if (dev@)
		dev@ Device_Name + devname!
	end else
		"(none)" devname!
	end

	fs@ Filesystem_Name + @ pname@ devname@ "mounted %s on %s as %s\n" Printf
end

fn VFSUnmount { mount -- ok }
	auto rs
	InterruptDisable rs!

	if (mount@ Mount_MRefs + @ 0 ~=)
		-EBUSY ok!
		rs@ InterruptRestore
		return
	end

	if (mount@ Mount_VRefs + @ 1 >)
		-EBUSY ok!
		rs@ InterruptRestore
		return
	end

	if (LockMountList)
		rs@ InterruptRestore
		-EINTR ok!
		return
	end

	1 mount@ Mount_Busy + !

	mount@ MountRef

	rs@ InterruptRestore

	auto root
	mount@ Mount_Root + @ root!

	if (root@ VNode_Refs + @ 1 ~=)
		(* should have caught this earlier *)
		root@ VNode_Refs + @ "VFSUnmount: root has %d references\n" Panic
	end

	root@ VNodeUnref

	auto covering

	mount@ Mount_Covering + @ covering!

	if (covering@)
		0 covering@ VNode_CoveredBy + !
		covering@ VNodeUnref
	end

	mount@ 1 SyncVNodes ok!

	if (ok@ iserr)
		ok@ abs ok!
		[ok@]ErrorNames@ "VFSUnmount: couldn't sync: %s\n" Printf
	end
	
	(* for when block cache works: *)
	(* mount@ Mount_Device + @ SyncBlocks *)

	auto link
	mount@ Mount_Next + @ link!

	if (mount@ MountListHead@ ==)
		link@ MountListHead!
	end

	if (link@)
		mount@ Mount_Prev + @ link@ Mount_Prev + !
	end

	mount@ Mount_Prev + @ link!

	if (link@)
		mount@ Mount_Next + @ link@ Mount_Next + !
	end

	UnlockMountList

	auto fs
	mount@ Mount_Filesystem + @ fs!

	mount@ fs@ Filesystem_Unmount + @ FSUnmount ok!

	mount@ Free
end

fn VForbidden { vnode rwx uid -- ok }
	auto fl
	vnode@ VNode_Mount + @ Mount_Flags + @ fl!

	auto bits
	vnode@ VNode_Permissions + @ bits!

	auto permbits

	if (uid@ 0 ==) (* superuser *)
		7 permbits!
	end else
		auto shift
		if (vnode@ VNode_UID + @ uid@ ==)
			6 shift! (* owner *)
		end else (* world; groups NYI *)
			0 shift!
		end

		bits@ shift@ >> 7 & permbits!

		if (fl@ FS_NOUID &)
			WORLD_W WORLD_R | permbits |=
		end
	end

	0 ok!

	if (permbits@ rwx@ | permbits@ ~=)
		-EACCES ok!
	end

	if (vnode@ VNode_Type + @ VNODE_DIR ~=)
		if (rwx@ WORLD_X & bits@ XMASK & 0 == &&)
			-EACCES ok!
		end
	end

	if (rwx@ WORLD_W &)
		if (fl@ FS_READONLY &)
			-EROFS ok!
		end
	end
end

fn VFSSyncWorker { -- }
	while (1)
		if (3000 SleepFor)
			"sync thread killed in its sleep\n" Panic
		end

		if (LockMountList)
			"sync thread killed while locking mount list\n" Panic
		end

		auto mount

		MountListHead@ mount!

		while (mount@)
			mount@ 0 SyncVNodes r!

			if (r@ -EINTR ==)
				"sync thread killed\n" Panic
			end

			mount@ Mount_Next + @ mount!
		end

		UnlockMountList

		auto r
		bsync r!

		if (r@ iserr)
			r@ abs r!
			[r@]ErrorNames@ "block cache sync error: %s\n" Printf
		end
	end
end

fn VFSPrintMounts { -- }
	auto mount

	MountListHead@ mount!
	while (mount@)
		auto dev
		mount@ Mount_Device + @ dev!

		auto path
		mount@ Mount_Path + path!

		auto fs
		mount@ Mount_Filesystem + @ fs!

		auto devname
		if (dev@)
			dev@ Device_Name + devname!
		end else
			"(none)" devname!
		end

		fs@ Filesystem_Name + @ path@ devname@ "%s on /%s as %s\n" Printf

		mount@ Mount_Next + @ mount!
	end
end