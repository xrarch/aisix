#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"

const FilePTabSZ (MAXFILEP FileP_SIZEOF *)

buffer FilePTab FilePTabSZ

table ModeBits
	0
	WORLD_R
	WORLD_W
	(WORLD_R WORLD_W |)
endtable

fn private OnlyFD { -- fd }
	auto i
	0 i!

	auto ofile
	CurrentThread@ Thread_Process + @ Process_OFiles + ofile!

	-EMFILE fd!

	while (i@ OFILEMAX <)
		if (ofile@@ 0 ==)
			i@ fd!
			return
		end

		4 ofile +=
		1 i +=
	end
end

fn GetFD { bits -- fd filp }
	OnlyFD fd!

	if (fd@ iserr)
		return
	end

	FilePTab filp!

	auto m
	FilePTab FilePTabSZ + m!

	while (filp@ m@ <)
		auto rs
		InterruptDisable rs!

		if (filp@ FileP_Count + @ 0 ==)
			1 filp@ FileP_Count + !

			rs@ InterruptRestore

			0 filp@ FileP_Seek + !
			bits@ filp@ FileP_RWX + !
			0 filp@ FileP_VDirent + !

			return
		end

		rs@ InterruptRestore

		FileP_SIZEOF filp +=
	end

	-ENFILE fd!
end

fn GetFilp { fd -- filp }
	if (fd@ iserr fd@ OFILEMAX >= ||)
		-EBADF filp!
		return
	end

	auto ofile
	CurrentThread@ Thread_Process + @ Process_OFiles + ofile!

	fd@ 4 * ofile@ + @ filp!

	if (filp@ 0 ==)
		-EBADF filp!
		return
	end

	if (filp@ FileP_Count + @ 0 ==)
		"filp count 0\n" Panic
	end
end

fn RefFilp { filp -- }
	auto rs
	InterruptDisable rs!

	1 filp@ FileP_Count + +=

	rs@ InterruptRestore
end

fn UnrefFilp { filp -- }
	auto rs
	InterruptDisable rs!

	1 filp@ FileP_Count + -=

	rs@ InterruptRestore
end

fn UnguardFilp { filp -- }
	if (filp@ FileP_Count + @ 1 ==)
		filp@ CloseP drop
		return
	end

	auto rs
	InterruptDisable rs!

	1 filp@ FileP_Count + -=

	rs@ InterruptRestore
end

fn FDup { filp -- }
	filp@ RefFilp
	filp@ FileP_VNode + @ VNodeRef
end

fn FilDup { fd1 -- fd2 }
	fd1@ GetFilp fd1!

	if (fd1@ iserr)
		fd1@ fd2!
	end

	OnlyFD fd2!

	if (fd2@ iserr)
		return
	end

	fd1@ FDup

	auto ofile
	CurrentThread@ Thread_Process + @ Process_OFiles + ofile!

	fd1@ fd2@ 4 * ofile@ + !
end

fn private VOpen { path rwx mode pbits -- vnode }
	auto dirvnode
	auto name
	auto sook
	path@ VFSPathX name! vnode! dirvnode! sook!

	if (vnode@ iserr)
		if (vnode@ -ENOENT == mode@ O_CREATE & && sook@ &&)
			CurrentThread@ Thread_Process + @ Process_UMask + @ ~ pbits &=

			auto mount
			dirvnode@ VNode_Mount + @ mount!

			dirvnode@
			name@
			VNODE_FILE
			CurrentThread@ Thread_Process + @ Process_UID + @
			pbits@
			mount@ Mount_Filesystem + @ Filesystem_Create + @ FSCreate vnode!

			if (name@)
				name@ Free
			end

			if (dirvnode@)
				dirvnode@ VNodePut
			end

			if (vnode@ iserr)
				return
			end

			vnode@ mount@ VNodeGet vnode!

			return
		end else
			if (name@)
				name@ Free
			end

			if (dirvnode@)
				dirvnode@ VNodePut
			end

			return
		end
	end

	if (name@)
		name@ Free
	end

	if (dirvnode@)
		dirvnode@ VNodePut
	end

	auto r
	vnode@ rwx@ CurrentThread@ Thread_Process + @ Process_EUID + @ VForbidden r!

	if (r@ iserr)
		vnode@ VNodePut
		r@ vnode!
	end
end

fn Open { path mode pbits -- fd }
	if (mode@ 3 & 0 ==)
		-EINVAL fd!
		return
	end
	
	auto bits
	[mode@ 3 &]ModeBits@ bits!

	if (mode@ O_TRUNC &)
		if (bits@ WORLD_W & ~~)
			-EINVAL fd!
			return
		end
	end

	auto filp
	bits@ GetFD filp! fd!

	if (fd@ iserr)
		return
	end

	FD_FILE filp@ FileP_Type + !

	mode@ filp@ FileP_Flags + !

	auto r

	auto vnode
	path@ bits@ mode@ pbits@ VOpen vnode!

	if (vnode@ iserr)
		filp@ UnrefFilp
		vnode@ fd!
		return
	end

	auto p
	CurrentThread@ Thread_Process + @ p!

	auto type
	vnode@ VNode_Type + @ type!

	if (type@ VNODE_DIR ==)
		if (bits@ WORLD_W &)
			filp@ UnrefFilp
			vnode@ VNodePut
			-EISDIR fd!
			return
		end
	end elseif (type@ VNODE_FILE ==)
		if (mode@ O_TRUNC &)
			vnode@ VTrunc r!

			if (r@ iserr)
				filp@ UnrefFilp
				vnode@ VNodePut
				r@ fd!
				return
			end
		end
	end elseif (type@ VNODE_CHAR ==)
		if (p@ Process_TTY + @ ~~)
			(* devfs uses its vnodes' fsdata to store the dev pointer *)
			(* no other fs driver should be giving nodes of VNODE_CHAR !!! *)
			vnode@ VNode_FSData + @ Device_TTY + @ p@ Process_TTY + !
		end

		vnode@ VNode_FSData + @ DeviceOpen r!

		if (r@ iserr)
			filp@ UnrefFilp
			vnode@ VNodePut
			r@ fd!
			return
		end
	end elseif (type@ VNODE_BLOCK ==)
		vnode@ VNode_FSData + @ DeviceOpen r!

		if (r@ iserr)
			filp@ UnrefFilp
			vnode@ VNodePut
			r@ fd!
			return
		end
	end

	vnode@ filp@ FileP_VNode + !

	auto ofile
	CurrentThread@ Thread_Process + @ Process_OFiles + ofile!

	filp@ fd@ 4 * ofile@ + !

	if (mode@ O_APPEND &)
		vnode@ VNode_Size + @ filp@ FileP_Seek + !
	end

	vnode@ VNodeUnlock
end

fn Close { fd -- ok }
	auto filp
	fd@ GetFilp filp!

	if (filp@ iserr)
		filp@ ok!
		return
	end

	filp@ CloseP ok!

	auto ofile
	CurrentThread@ Thread_Process + @ Process_OFiles + ofile!

	0 fd@ 4 * ofile@ + !
end

fn CloseP { filp -- ok }
	auto vnode
	filp@ FileP_VNode + @ vnode!

	auto type
	vnode@ VNode_Type + @ type!

	if (type@ VNODE_CHAR == type@ VNODE_BLOCK == ||)
		vnode@ VNode_FSData + @ DeviceClose ok!
	end else
		0 ok!
	end

	vnode@ VNodeUnref

	auto rs
	InterruptDisable rs!

	if (filp@ FileP_Count + @ 1 ==)
		(* last holder, free resources associated with the filp *)

		auto vd
		filp@ FileP_VDirent + @ vd!

		filp@ UnrefFilp

		rs@ InterruptRestore

		if (vd@)
			vd@ Free
		end
	end else
		filp@ UnrefFilp

		rs@ InterruptRestore
	end
end

fn Write { buf len fd -- bytes }
	auto filp
	fd@ GetFilp filp!

	if (filp@ iserr)
		filp@ bytes!
		return
	end

	if (filp@ FileP_RWX + @ WORLD_W & ~~)
		-EACCES bytes!
		return
	end

	auto vnode
	filp@ FileP_VNode + @ vnode!

	(* so it doesnt get closed by another thread and reallocated while we're using it *)
	filp@ RefFilp

	buf@ len@ filp@ FileP_Seek + @ filp@ FileP_VNode + @ VWrite bytes!

	filp@ UnguardFilp

	if (bytes@ iserr)
		return
	end

	auto rs
	InterruptDisable rs!

	bytes@ filp@ FileP_Seek + +=

	rs@ InterruptRestore
end

fn Read { buf len fd -- bytes }
	auto filp
	fd@ GetFilp filp!

	if (filp@ iserr)
		filp@ bytes!
		return
	end

	if (filp@ FileP_RWX + @ WORLD_R & ~~)
		-EACCES bytes!
		return
	end

	auto vnode
	filp@ FileP_VNode + @ vnode!

	(* so it doesnt get closed by another thread and reallocated while we're using it *)
	filp@ RefFilp

	buf@ len@ filp@ FileP_Seek + @ filp@ FileP_VNode + @ VRead bytes!

	filp@ UnguardFilp

	if (bytes@ iserr)
		return
	end

	auto rs
	InterruptDisable rs!

	bytes@ filp@ FileP_Seek + +=

	rs@ InterruptRestore
end

fn ReadDir { dirent fd -- ok }
	auto filp
	fd@ GetFilp filp!

	if (filp@ iserr)
		filp@ ok!
		return
	end

	auto vnode
	filp@ FileP_VNode + @ vnode!

	if (vnode@ VNode_Type + @ VNODE_DIR ~=)
		-ENOTDIR ok!
		return
	end

	if (filp@ FileP_RWX + @ WORLD_R & ~~)
		-EACCES ok!
		return
	end

	auto fs
	vnode@ VNode_Mount + @ Mount_Filesystem + @ fs!

	auto rs
	InterruptDisable rs!

	auto vd
	filp@ FileP_VDirent + @ vd!

	if (vd@ ~~)
		VDirent_SIZEOF Calloc vd!

		vd@ filp@ FileP_VDirent + !

		vnode@ vd@ VDirent_DirVNode + !

		vd@ fs@ Filesystem_RewindDir + @ FSRewindDir ok!

		rs@ InterruptRestore

		if (ok@ iserr)
			0 filp@ FileP_VDirent + !
			vd@ Free
			return
		end
	end else
		rs@ InterruptRestore
	end

	vd@ fs@ Filesystem_ReadDir + @ FSReadDir ok!

	if (ok@ iserr)
		return
	end

	dirent@ Dirent_Name + vd@ VDirent_Name + @ 255 strncpy

	if (vd@ VDirent_Cookie + @)
		vd@ VDirent_Cookie + @ Free
		0 vd@ VDirent_Cookie + !
	end
end

fn VStat { stat vnode -- ok }
	if (stat@ 3 &)
		-EINVAL ok!
		return
	end

	0 ok!

	vnode@ VNode_Permissions + @ stat@ Stat_Mode + !
	vnode@ VNode_UID + @ stat@ Stat_UID + !
	vnode@ VNode_GID + @ stat@ Stat_GID + !
	vnode@ VNode_Size + @ stat@ Stat_Size + !
	vnode@ VNode_Type + @ stat@ Stat_Type + !
	vnode@ VNode_Timestamp + @ stat@ Stat_CTime + !
	vnode@ VNode_Timestamp + @ stat@ Stat_ATime + !
	vnode@ VNode_Timestamp + @ stat@ Stat_MTime + !
end

fn PStat { stat path -- ok }
	auto vnode
	path@ VFSPath vnode!

	if (vnode@ iserr)
		vnode@ ok!
		return
	end

	stat@ vnode@ VStat ok!

	vnode@ VNodePut
end

fn FStat { stat fd -- ok }
	auto filp
	fd@ GetFilp filp!

	if (filp@ iserr)
		filp@ ok!
		return
	end

	auto vnode
	filp@ FileP_VNode + @ vnode!

	stat@ vnode@ VStat ok!
end

fn Chdir { path -- ok }
	0 ok!

	auto vnode
	path@ VFSPath vnode!

	if (vnode@ iserr)
		vnode@ ok!
		return
	end

	auto p
	CurrentThread@ Thread_Process + @ p!

	vnode@ WORLD_R p@ Process_EUID + @ VForbidden ok!

	if (ok@ iserr)
		vnode@ VNodePut
		return
	end

	p@ Process_CWDVNode + @ VNodeUnref

	vnode@ p@ Process_CWDVNode + !

	vnode@ VNodeUnlock
end

fn Unlink { path -- ok }
	auto dirvnode
	auto vnode
	auto name
	path@ VFSPathX name! vnode! dirvnode! drop

	if (vnode@ iserr)
		if (name@)
			name@ Free
		end

		if (dirvnode@)
			dirvnode@ VNodePut
		end

		vnode@ ok!
		return
	end

	if (vnode@ VNode_Mount + @ Mount_Root + @ vnode@ ==)
		if (name@)
			name@ Free
		end

		if (dirvnode@)
			dirvnode@ VNodePut
		end

		vnode@ VNodePut

		-EBUSY ok!
		return
	end

	vnode@ WORLD_W CurrentThread@ Thread_Process + @ Process_EUID + @ VForbidden ok!

	if (ok@ iserr)
		if (name@)
			name@ Free
		end

		if (dirvnode@)
			dirvnode@ VNodePut
		end

		vnode@ VNodePut
		return
	end

	auto fs
	vnode@ VNode_Mount + @ Mount_Filesystem + @ fs!

	dirvnode@ vnode@ name@ fs@ Filesystem_Unlink + @ FSUnlink ok!

	if (name@)
		name@ Free
	end
	
	if (dirvnode@)
		dirvnode@ VNodePut
	end

	vnode@ VNodePut
end

fn Mkdir { path mode -- ok }
	CurrentThread@ Thread_Process + @ Process_UMask + @ ~ mode &=

	auto dirvnode
	auto vnode
	auto name
	auto sook
	path@ VFSPathX name! vnode! dirvnode! sook!

	if (vnode@ iserr ~~)
		if (name@)
			name@ Free
		end

		if (dirvnode@)
			dirvnode@ VNodePut
		end

		vnode@ VNodePut

		-EEXIST ok!
		return
	end

	if (vnode@ iserr vnode@ -ENOENT ~= &&)
		if (name@)
			name@ Free
		end

		if (dirvnode@)
			dirvnode@ VNodePut
		end

		vnode@ ok!
		return
	end

	if (vnode@ -ENOENT ~=)
		"mkdir\n" Panic
	end

	if (sook@ ~~)
		if (name@)
			name@ Free
		end

		if (dirvnode@)
			dirvnode@ VNodePut
		end

		-ENOENT ok!
		return
	end

	dirvnode@ WORLD_W CurrentThread@ Thread_Process + @ Process_EUID + @ VForbidden ok!

	if (ok@ iserr)
		if (name@)
			name@ Free
		end

		if (dirvnode@)
			dirvnode@ VNodePut
		end

		return
	end

	auto fs
	dirvnode@ VNode_Mount + @ Mount_Filesystem + @ fs!

	dirvnode@
	name@
	VNODE_DIR
	CurrentThread@ Thread_Process + @ Process_UID + @
	mode@
	fs@ Filesystem_Create + @ FSCreate ok!

	if (name@)
		name@ Free
	end

	if (dirvnode@)
		dirvnode@ VNodePut
	end

	if (ok@ iserr ~~)
		0 ok!
	end
end

fn Chown { path owner -- ok }
	auto vnode
	path@ VFSPath vnode!

	if (vnode@ iserr)
		vnode@ ok!
		return
	end

	auto fl
	vnode@ VNode_Mount + @ Mount_Flags + @ fl!

	if (fl@ FS_READONLY &)
		-EROFS ok!
		vnode@ VNodePut
		return
	end

	if (fl@ FS_NOUID & ~~)
		auto uid
		CurrentThread@ Thread_Process + @ Process_EUID + @ uid!

		if (uid@ 0 ~=)
			if (owner@ uid@ ~= vnode@ VNode_UID + @ uid@ ~= ||)
				vnode@ VNodePut
				-EPERM ok!
				return
			end
		end
	end

	owner@ vnode@ VNode_UID + !
	SUID ~ vnode@ VNode_Permissions + &=
	1 vnode@ VNode_Dirty + !

	vnode@ VNodePut
	0 ok!
end

fn Chmod { path mode -- ok }
	auto vnode
	path@ VFSPath vnode!

	if (vnode@ iserr)
		vnode@ ok!
		return
	end

	auto fl
	vnode@ VNode_Mount + @ Mount_Flags + @ fl!

	if (fl@ FS_READONLY &)
		-EROFS ok!
		vnode@ VNodePut
		return
	end

	if (fl@ FS_NOUID & ~~)
		auto uid
		CurrentThread@ Thread_Process + @ Process_EUID + @ uid!

		if (uid@ 0 ~=)
			if (vnode@ VNode_UID + @ uid@ ~=)
				vnode@ VNodePut
				-EPERM ok!
				return
			end
		end
	end

	mode@ 1023 & vnode@ VNode_Permissions + !
	1 vnode@ VNode_Dirty + !

	vnode@ VNodePut
	0 ok!
end

fn Seek { fd offset whence -- ok }
	if (whence@ 0 ==)
		-EINVAL ok!
		return
	end

	if (whence@ SEEK_END >)
		-EINVAL ok!
		return
	end

	auto filp
	fd@ GetFilp filp!

	if (filp@ iserr)
		filp@ ok!
		return
	end

	auto vn
	filp@ FileP_VNode + @ vn!

	auto nseek
	0 nseek!

	if (whence@ SEEK_SET ==)
		offset@ nseek!
	end elseif (whence@ SEEK_CUR ==)
		offset@ filp@ FileP_Seek + @ + nseek!
	end elseif (whence@ SEEK_END ==)
		offset@ vn@ VNode_Size + @ + nseek!
	end

	if (nseek@ 0 s<)
		-EINVAL ok!
		return
	end

	nseek@ filp@ FileP_Seek + !

	0 ok!
end