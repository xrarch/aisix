#include "<df>/dragonfruit.h"
#include "<inc>/mk.h"

const SYSCALLNUM 13

table Syscalls
	pointerof SyscallPutc
	pointerof SyscallExit
	pointerof SyscallYield
	pointerof SyscallGetc
	pointerof SyscallSetUserID
	pointerof SyscallAddService
	pointerof SyscallServiceByName
	pointerof SyscallGetPID
	pointerof SyscallSetUserSeg
	pointerof SyscallNewThread
	pointerof SyscallAtomicLock
	pointerof SyscallWait
	pointerof SyscallThreadExit
endtable

extern ThreadExit

extern ThreadPick

extern ProcessUser

procedure Syscall { num -- ret }
	if (num@ SYSCALLNUM >=)
		-1 ret!
		return
	end

	[num@]Syscalls@ Call ret!
end


(* call 0 *)
procedure SyscallPutc { -- ret }
	if (ProcessUser 0 ==)
		auto c
		CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ c!

		c@ Putc

		0 ret!
	end else
		-1 ret!
	end
end

extern ProcessExit

(* call 1 *)
procedure SyscallExit { -- ret }
	auto r

	CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ r!

	auto proc

	CurrentThread@ Thread_Process + @ proc!

	r@ proc@ ProcessExit

	0 ret! (* even though thread wont run again *)
end

(* call 2 *)
procedure SyscallYield { -- ret }
	ThreadPick

	0 ret!
end

(* call 3 *)
procedure SyscallGetc { -- ret }
	if (ProcessUser 0 ==)
		Getc ret!
	end else
		-1 ret!
	end
end

extern ProcessSetUserID

(* call 4 *)
procedure SyscallSetUserID { -- ret }
	if (ProcessUser 0 ==)
		CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ ProcessSetUserID

		0 ret!
	end else
		-1 ret!
	end
end

extern PlatformTranslateVAddr

extern ServiceAdd

(* call 5 *)
procedure SyscallAddService { -- ret }
	-1 ret!

	if (ProcessUser 0 ==)
		auto sname
		auto slen
		CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ sname!
		CurrentThread@ Thread_StackFrame + @ TrapFrame_r2 + @ slen!

		auto addr
		sname@ slen@ PlatformTranslateVAddr addr!

		if (addr@ -1 ==)
			return
		end

		if (addr@ CurrentThread@ Thread_Process + @ Process_ProcessID + @ ServiceAdd)
			0 ret!
		end
	end
end

extern ServiceByName

(* call 6 *)
procedure SyscallServiceByName { -- ret }
	auto sname
	auto slen
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ sname!
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r2 + @ slen!

	auto addr
	sname@ slen@ PlatformTranslateVAddr addr!

	if (addr@ -1 ==)
		-1 ret!
		return
	end

	addr@ ServiceByName ret!
end

(* call 7 *)
procedure SyscallGetPID { -- ret }
	CurrentThread@ Thread_Process + @ Process_ProcessID + @ ret!
end

(* call 8 *)
procedure SyscallSetUserSeg { -- ret }
	if (ProcessUser 0 ~=)
		-1 ret!
		return
	end

	auto segbase
	auto segsize
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ segbase!
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r2 + @ segsize!

	segbase@ CurrentThread@ Thread_UserSegPhysAddr + !
	segsize@ CurrentThread@ Thread_UserSegSize + !

	0 ret!
end

extern ThreadNew

(* call 9 *)
procedure SyscallNewThread { -- ret }
	auto threadpc
	auto data
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ threadpc!
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r2 + @ data!

	auto proc
	CurrentThread@ Thread_Process + @ proc!

	auto thread
	4096 proc@ threadpc@ ThreadNew thread!

	if (thread@ -1 ==)
		-1 ret!
		return
	end else
		0 ret!
	end

	data@ thread@ Thread_StackFrame + @ TrapFrame_r0 + !
end

(* call 10 *)
procedure SyscallAtomicLock { -- ret }
	auto ptr
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ ptr!

	auto addr
	ptr@ 4 PlatformTranslateVAddr addr!

	if (addr@ -1 ==)
		-1 ret!
		return
	end

	if (addr@ @ 1 ==)
		0 ret!
		return
	end

	1 addr@ !

	1 ret!
end

extern ProcessFreeSlot

extern ProcessByPID

externconst ProcessTable

(* call 11 *)
procedure SyscallWait { -- ret }
	-1 ret!

	auto pidarg
	CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + @ pidarg!

	auto proc
	0 proc!

	auto zombie
	0 zombie!

	auto myproc
	CurrentThread@ Thread_Process + @ myproc!

	if (pidarg@ 0 ~=)
		pidarg@ ProcessByPID proc!

		if (proc@ -1 ==)
			return
		end

		if (proc@ Process_Parent + @ myproc@ ~=)
			return
		end

		if (proc@ Process_Status + @ PZOMBIE ==)
			1 zombie!
		end
	end else
		auto i
		0 i!

		while (i@ PROCNUM <)
			auto p
			i@ Process_SIZEOF * ProcessTable@ + p!

			if (p@ Process_Status + @ PZOMBIE ==)
				if (p@ Process_Parent + @ myproc@ ==)
					p@ proc!

					1 zombie!

					break
				end
			end

			1 i +=
		end
	end

	if (zombie@)
		proc@ Process_Return + @ ret!

		proc@ Process_ProcessID + @ CurrentThread@ Thread_StackFrame + @ TrapFrame_r1 + !

		proc@ ProcessFreeSlot

		return
	end

	if (pidarg@ 0 ~=)
		WAITING CurrentThread@ Thread_Status + !

		CurrentThread@ proc@ Process_WaitedBy + !

		proc@ Process_ProcessID + @ "waiting for %d\n" Printf
	end else
		WAITINGANY CurrentThread@ Thread_Status + !
	end

	ThreadPick

	(* still returns -1 cuz the real value is set later *)
end

(* call 12 *)
procedure SyscallThreadExit { -- ret }
	CurrentThread@ ThreadExit

	ThreadPick

	0 ret!
end