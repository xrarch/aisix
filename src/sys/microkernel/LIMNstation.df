#include "<df>/dragonfruit.h"
#include "<ll>/rta3x/a3x.h"
#include "<inc>/mk.h"

extern AISIX

const CompatibleFirmware 30500

const KBase 0x80000

var Kr5 0

var IntTable 0

procedure Main { ksz args -- ret }
	0 ret!

	auto vnum
	"/" a3xDeviceSelect
		"versionNum" a3xDGetProperty vnum!
	a3xDeviceExit

	if (vnum@ CompatibleFirmware <)
		"aisix requires newer firmware!\n" Printf
		return
	end

	ResetBus
	asm "cli"

	"/platform" a3xDeviceSelect
		"model" a3xDGetProperty MachineType!
	a3xDeviceExit

	"/cpu" a3xDeviceSelect
		"model" a3xDGetProperty MachineCPU!
	a3xDeviceExit

	"/bus" a3xDeviceSelect
		"model" a3xDGetProperty MachineBus!
	a3xDeviceExit

	auto tram

	"/memory" a3xDeviceSelect
		"totalRAM" a3xDGetProperty tram!
	a3xDeviceExit

	KBase ksz@ +
	4096 / 1 + 4096 * (* round to nearest 4096 bytes, ceil *)
	MachineRAMBase!

	tram@ MachineRAMBase@ - MachineRAMSize!

	4096 Malloc Kr5!

	if (Kr5@ ERR ==)
		"no kernel dragonfruit stack :(\n" Printf
		return
	end

	4096 Kr5 +=

	1024 Calloc IntTable!

	if (IntTable@ ERR ==)
		"no kernel interrupt table :(\n" Printf
		return
	end

	"\nmicrokernel log to a3x console\n" Printf

	ksz@ args@ AISIX
end

procedure ResetBus (* -- *)
	"/bus" a3xDeviceSelect
		"reset" a3xDCallMethod drop
	a3xDeviceExit
end

procedure Shutdown (* -- *)
	ResetBus

	0 a3xReturn
end

procedure Reboot (* -- *)
	"/cpu" a3xDeviceSelect
		"reset" a3xDCallMethod drop
	a3xDeviceExit

	while (1) end
end

procedure PlatformPanic (* -- *)
	-1 a3xReturn
end

var AisixIVT 0

procedure InterruptsInit (* -- *)
	256 4 * Calloc AisixIVT!

	if (AisixIVT@ -1 ==)
		"couldn't allocate ivt\n" Panic
	end

	auto a3xIVT
	asm "
		pushv r5, ivt
	" a3xIVT!

	(* copy a3x fault handlers for now *)
	auto i
	0 i!
	while (i@ 10 <)
		a3xIVT@ i@ 4 * + @
		i@
		PlatformInterruptRegister

		1 i +=
	end

	(* set new ivt *)
	AisixIVT@ asm "
		popv r5, ivt
	"
end

procedure PlatformFaultsInit { -- }
	auto i
	0 i!
	while (i@ 10 <)
		pointerof PlatformFault
		i@
		PlatformInterruptRegister

		1 i +=
	end

	while (i@ 16 <)
		pointerof PlatformSyscall
		i@
		PlatformInterruptRegister

		1 i +=
	end
end

extern Syscall

procedure PlatformSyscall { num -- }
	auto sysnum

	auto ksp
	CurrentThread@ Thread_StackFrame + @ ksp!

	ksp@ TrapFrame_r0 + @ sysnum!

	auto ret
	sysnum@ Syscall ret!

	ret@ ksp@ TrapFrame_r0 + !
end

table FaultsNames
	"Division by zero"
	"Invalid opcode"
	"Segmentation fault"
	"Privilege violation"
	"General fault"
	"Breakpoint"
	"Unknown"
	"Bus error"
	"Unknown"
	"Spurious interrupt"
endtable

extern ThreadFree

extern ThreadPick

extern ProcessExit

const MMUConfigBadAddr 0xB8000010

procedure PlatformFault { fault -- }
	auto ksp
	CurrentThread@ Thread_StackFrame + @ ksp!

	auto fa
	asm "

	pushv r5, fa

	" fa!

	fa@ [fault@]FaultsNames@ "%s at pc0x%x " Printf

	if (fault@ 2 ==)
		MMUConfigBadAddr@ "(vaddr = 0x%x) " Printf
	end

	if (ksp@ TrapFrame_rs + @ 1 & 0 ==)
		"occurred in kernel mode!\n" Printf

		"unexpected kernel trap\n" Panic
	end

	auto procn

	if (CurrentThread@ 0 ==)
		"none yet" procn!
	end else
		CurrentThread@ Thread_Process + @ Process_Name + procn!
	end

	CurrentThread@ procn@ "killed process %s (thread: %x)\n" Printf

	PlatformSegmentDump

	-1 CurrentThread@ Thread_Process + @ ProcessExit
end

procedure PlatformInterruptRegister { handler num -- }
	handler@ num@ 4 * IntTable@ + !

	pointerof PlatformKernelEntry num@ 4 * AisixIVT@ + !
end

procedure PlatformPrepareKStack { pc thread -- }
	auto kstack
	thread@ Thread_KernelStackAddr + @ kstack!

	auto ksp
	kstack@ 4096 + TrapFrame_SIZEOF - ksp!

	ksp@ thread@ Thread_StackFrame + !

	ksp@ TrapFrame_SIZEOF 0 memset

	pc@ ksp@ TrapFrame_pc + !

	auto proc
	thread@ Thread_Process + @ proc!

	if (proc@ Process_KernelMode + @)
		6 ksp@ TrapFrame_rs + !
	end else
		7 ksp@ TrapFrame_rs + !
	end

	STACKMAPADDR thread@ Thread_StackSize + @ + ksp@ TrapFrame_usp + !
	HEAPMAPADDR ksp@ TrapFrame_r0 + !
	proc@ Process_HeapSize + @ ksp@ TrapFrame_r1 + !
end

const MMUConfigSEG0REAL 0xB8000014
const MMUConfigSEG0SIZE 0xB8000018
const MMUConfigSEG0MAP 0xB800001C

const MMUConfigSEG1REAL 0xB8000020
const MMUConfigSEG1SIZE 0xB8000024
const MMUConfigSEG1MAP 0xB8000028

const MMUConfigSEG2REAL 0xB800002C
const MMUConfigSEG2SIZE 0xB8000030
const MMUConfigSEG2MAP 0xB8000034

const MMUConfigSEG3REAL 0xB8000038
const MMUConfigSEG3SIZE 0xB800003C
const MMUConfigSEG3MAP 0xB8000040

externconst NextThread

externconst ThreadTable

externconst IdleProc

asm "

ThreadPick:
.global ThreadPick
	pusha

	lri.l r0, CurrentThread
	lri.l r1, ThreadTable

	sub r2, r0, r1
	addi r2, r2, Thread_SIZEOF

	li r3, 0

	li r4, THREADNUM
	muli r4, r4, Thread_SIZEOF

.loop:
	cmpi r3, THREADNUM
	bge .goidle

	mod r5, r2, r4
	add r5, r5, r1

	addi r6, r5, Thread_Status
	lrr.l r6, r6
	cmpi r6, 0
	be .found

	addi r3, r3, 1
	addi r2, r2, Thread_SIZEOF
	b .loop

.found:
	sir.l NextThread, r5

	popa
	ret
	
.goidle:
	lri.l r0, IdleProc
	addi r0, r0, Process_MainThread
	lrr.l r0, r0
	sir.l NextThread, r0

	popa
	ret

ThreadResume:
.global ThreadResume
	lri.l r0, NextThread
	cmpi r0, 0
	be .load
	sir.l CurrentThread, r0

	;new thread, switch segments

	addi r1, r0, Thread_Process
	lrr.l r2, r1 ;r2 - proc

	addi r1, r2, Process_ImagePhysAddr
	lrr.l r1, r1
	sir.l MMUConfigSEG0REAL, r1
	addi r1, r2, Process_ImageSize
	lrr.l r1, r1
	sir.l MMUConfigSEG0SIZE, r1
	sii.l MMUConfigSEG0MAP, IMAGEMAPADDR

	addi r1, r0, Thread_StackPhysAddr
	lrr.l r1, r1
	sir.l MMUConfigSEG1REAL, r1
	addi r1, r0, Thread_StackSize
	lrr.l r1, r1
	sir.l MMUConfigSEG1SIZE, r1
	sii.l MMUConfigSEG1MAP, STACKMAPADDR

	addi r1, r2, Process_HeapPhysAddr
	lrr.l r1, r1
	sir.l MMUConfigSEG2REAL, r1
	addi r1, r2, Process_HeapSize
	lrr.l r1, r1
	sir.l MMUConfigSEG2SIZE, r1
	sii.l MMUConfigSEG2MAP, HEAPMAPADDR

	addi r1, r0, Thread_UserSegPhysAddr
	lrr.l r1, r1
	sir.l MMUConfigSEG3REAL, r1
	addi r1, r0, Thread_UserSegSize
	lrr.l r1, r1
	sir.l MMUConfigSEG3SIZE, r1
	sii.l MMUConfigSEG3MAP, USERSEGMAPADDR

	b .resume

.load:
	lri.l r0, CurrentThread ;r0 - thread

.resume:
	addi r1, r0, Thread_StackFrame
	lrr.l sp, r1

	popa
	pop usp
	iret

IdleThread:
.global IdleThread
	hlt
	b 0

"

procedure PlatformSegmentDump { -- }
	"SEG\tPHYS\tMAP\tSIZE\n" Printf

	auto ptr
	MMUConfigSEG0REAL ptr!

	auto i
	0 i!

	while (ptr@ MMUConfigSEG3MAP <)
		auto phys
		ptr@ @ phys!

		auto size
		ptr@ 4 + @ size!

		auto map
		ptr@ 8 + @ map!

		size@ map@ phys@ i@ "%d\t%x\t%x\t%d\n" Printf

		12 ptr +=
		1 i +=
	end
end

procedure PlatformUnmaskIRQ { irq -- }
	irq@ asm "

	popv r5, r0
	iunmask r0

	"
end

procedure PlatformMaskIRQ { irq -- }
	irq@ asm "

	popv r5, r0
	imask r0

	"
end

asm "

PlatformKernelEntry:
	push usp
	pusha

	lri.l r1, CurrentThread
	addi r1, r1, Thread_StackFrame
	srr.l r1, sp

	lri.l r5, Kr5

	pushv r5, r0

	lri.l r2, IntTable
	muli r1, r0, 4
	add r1, r1, r2

	lrr.l r1, r1
	cmpi r1, 0
	be .panic

	call .mock

	b ThreadResume

.mock:
	br r1

.panic:
	b BadInt
"

procedure BadInt (* int -- *)
	"interrupt %x occurred with no registered handler!\n" Panic
end

const DCitronBase 0xF8000000

procedure private DCitronInb (* port -- byte *)
	4 * DCitronBase + gb
end

procedure private DCitronIni (* port -- int *)
	4 * DCitronBase + gi
end

procedure private DCitronInl (* port -- long *)
	4 * DCitronBase + @
end

procedure private DCitronOutb (* byte port -- *)
	4 * DCitronBase + sb
end

procedure private DCitronOuti (* int port -- *)
	4 * DCitronBase + si
end

procedure private DCitronOutl (* long port -- *)
	4 * DCitronBase + !
end

procedure private DCitronCommand (* command port -- *)
	auto pbase
	4 * DCitronBase + pbase!

	while (pbase@ gb 0 ~=) end

	auto cmd
	cmd!

	cmd@ pbase@ sb

	while (pbase@ gb 0 ~=) end
end

(* doesn't wait for the device to report the operation as completed before returning *)
procedure private DCitronCommandASync (* command port -- *)
	auto pbase
	4 * DCitronBase + pbase!

	while (pbase@ gb 0 ~=) end

	auto cmd
	cmd!

	cmd@ pbase@ sb
end

const ClockPortCmd 0x20
const ClockPortA 0x21

extern ClockTick

procedure PlatformPauseClock (* -- *)
	0 ClockPortA DCitronOutl
	0x1 ClockPortCmd DCitronCommand
end

procedure PlatformStartClock (* -- *)
	CLOCKINTERVALMS ClockPortA DCitronOutl
	0x1 ClockPortCmd DCitronCommand
end

procedure PlatformInitClock (* -- *)
	pointerof ClockTick 0x22 PlatformInterruptRegister
end

procedure PlatformTranslateVAddr { vaddr size -- physaddr }
	ERR physaddr!

	auto mmurb
	MMUConfigSEG0REAL mmurb!

	auto seg
	0 seg!

	while (seg@ 4 <)
		auto segsize
		mmurb@ 4 + @ segsize!

		if (segsize@ 0 >)
			auto mapaddr
			mmurb@ 8 + @ mapaddr!

			auto segtop
			mapaddr@ segsize@ + 1 - segtop!

			auto valtop
			vaddr@ size@ + 1 - valtop!

			if (vaddr@ mapaddr@ >= valtop@ segtop@ <= &&)
				auto realaddr
				mmurb@ @ realaddr!

				vaddr@ mapaddr@ - realaddr@ + physaddr!
				break
			end
		end

		12 mmurb +=
		1 seg +=
	end
end

(* copy 40-byte message body efficiently *)
procedure PlatformCopyMessageBody { from to -- }
	from@ to@ asm "

	popv r5, r0 ;r0 - to
	popv r5, r1 ;r1 - from

	; ===== LONG 0, bytes 0-3 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 1, bytes 4-7 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 2, bytes 8-11 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 3, bytes 12-15 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 4, bytes 16-19 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 5, bytes 20-23 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 6, bytes 24-27 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 7, bytes 28-31 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 8, bytes 32-35 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	addi r0, r0, 4 ;increment to
	addi r1, r1, 4 ;increment from

	; ===== LONG 9, bytes 36-39 =====

	lrr.l r2, r1 ;load from
	srr.l r0, r2 ;save to

	"
end