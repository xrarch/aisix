#include "<df>/dragonfruit.h"
#include "<inc>/mk.h"

var ThreadTable 0
public ThreadTable

var ProcessTable 0
public ProcessTable

var CurrentThread 0
public CurrentThread

var NextThread 0
public NextThread

var IdleProc 0
public IdleProc

var InitProc 0
public InitProc

extern IdleThread

extern ThreadPick

procedure ThreadInit (* -- *)
	THREADNUM Thread_SIZEOF * 4096 / 1 + PMMAlloc ThreadTable!

	if (ThreadTable@ ERR ==)
		"couldn't allocate thread table\n" Panic
	end

	PROCNUM Process_SIZEOF * 4096 / 1 + PMMAlloc ProcessTable!

	if (ProcessTable@ ERR ==)
		"couldn't allocate process table\n" Panic
	end

	PROCNUM THREADNUM "max %d threads, %d processes\n" Printf

	auto i
	0 i!

	while (i@ THREADNUM <)
		auto thp
		i@ Thread_SIZEOF * ThreadTable@ + thp!

		thp@ Thread_SIZEOF 0 memset

		SLOT_FREE thp@ Thread_Status + !

		1 i +=
	end

	0 i!

	while (i@ PROCNUM <)
		i@ Process_SIZEOF * ProcessTable@ + thp!

		thp@ Process_SIZEOF 0 memset

		PFREE thp@ Process_Status + !

		1 i +=
	end

	1
	0
	1
	"idle"
	pointerof IdleThread
	16
	0
	0
	ProcessNew IdleProc!

	NOSCHED IdleProc@ Process_MainThread + @ Thread_Status + !
end

procedure private ThreadAllocateTID { -- tid }
	auto i
	0 i!

	while (i@ THREADNUM <)
		auto thp
		i@ Thread_SIZEOF * ThreadTable@ + thp!

		if (thp@ Thread_Status + @ SLOT_FREE ==)
			0 thp@ Thread_Status + !

			thp@ tid!
			return
		end

		1 i +=
	end

	"ThreadFindTID: no threads left\n" Panic
end

procedure private ThreadFreeTID { tid -- }
	SLOT_FREE tid@ Thread_Status + !
end

extern PlatformPrepareKStack

procedure ThreadNew { stacksize proc pc -- tid }
	ThreadAllocateTID tid!

	proc@ tid@ Thread_Process + !

	auto stack
	stacksize@ 4096 / 1 + PMMAlloc stack!

	if (stack@ -1 ==)
		tid@ ThreadFreeTID
		-1 tid!
		return
	end

	stack@ tid@ Thread_StackPhysAddr + !
	stacksize@ tid@ Thread_StackSize + !

	auto kstack
	1 PMMAlloc kstack!

	if (kstack@ -1 ==)
		tid@ ThreadFreeTID
		-1 tid!
		return
	end

	0 tid@ Thread_UserSegPhysAddr + !
	0 tid@ Thread_UserSegSize + !

	kstack@ tid@ Thread_KernelStackAddr + !

	1 proc@ Process_ThreadCount + +=

	pc@ tid@ PlatformPrepareKStack
end

procedure ThreadFree { tid -- }
	tid@ Thread_StackSize + @ 4096 / 1 +
	tid@ Thread_StackPhysAddr + @ PMMFree

	1 tid@ Thread_KernelStackAddr + @ PMMFree

	auto proc
	tid@ Thread_Process + @ proc!

	1 proc@ Process_ThreadCount + -=

	tid@ ThreadFreeTID
end

procedure ThreadExit { tid -- }
	tid@ ThreadFree

	auto proc
	tid@ Thread_Process + @ proc!

	if (proc@ Process_ThreadCount + @ 0 ==)
		0 proc@ ProcessExit
	end
end

(* implemented in asm elsewhere for speed
extern PlatformSwitchSegments

extern PlatformThreadResume

procedure ThreadResume { -- }

procedure ThreadPick { -- }
*)

(* =========== process management =========== *)

var NextPID 1

procedure private ProcessAllocateSlot { -- ptr }
	auto i
	0 i!

	while (i@ PROCNUM <)
		auto thp
		i@ Process_SIZEOF * ProcessTable@ + thp!

		if (thp@ Process_Status + @ PFREE ==)
			0 thp@ Process_Status + !

			if (NextPID@ 0xFFFFFFFF ==)
				"ProcessAllocateSlot: whoa ran out of our 4 billion PIDs somehow\n" Panic
			end

			NextPID@ thp@ Process_ProcessID + !
			1 NextPID +=

			thp@ ptr!
			return
		end

		1 i +=
	end

	"ProcessAllocateSlot: no procs left\n" Panic
end

procedure ProcessFreeSlot { ptr -- }
	PFREE ptr@ Process_Status + !
end

procedure ProcessNew { kmode entry wired name img imgsz heapsz stacksz -- proc }
	ProcessAllocateSlot proc!

	proc@ Process_Name + name@ PROCNAMESIZE 1 - strncpy

	0 proc@ Process_Service + !

	0 proc@ Process_WaitedBy + !

	img@ proc@ Process_ImagePhysAddr + !
	imgsz@ proc@ Process_ImageSize + !

	wired@ proc@ Process_Wired + !

	kmode@ proc@ Process_KernelMode + !

	if (CurrentThread@ 0 ==)
		0 proc@ Process_Parent + !
		0 proc@ Process_UserID + !
		0 proc@ Process_EUserID + !
	end else
		auto parent
		CurrentThread@ Thread_Process + @ parent!

		parent@ proc@ Process_Parent + !

		parent@ Process_UserID + @ dup
		proc@ Process_UserID + !
		proc@ Process_EUserID + !
	end

	auto heap
	heapsz@ 4096 / 1 + PMMAlloc heap!

	if (heap@ -1 ==)
		proc@ ProcessFreeSlot
		-1 proc!
		return
	end

	heap@ proc@ Process_HeapPhysAddr + !
	heapsz@ proc@ Process_HeapSize + !

	DEFAULTTIMESLICEMS proc@ Process_Timeslice + !

	auto mthread
	stacksz@ proc@ entry@ ThreadNew mthread!

	mthread@ proc@ Process_MainThread + !

	if (mthread@ -1 ==)
		proc@ ProcessFreeResources
		proc@ ProcessFreeSlot
		-1 proc!
		return
	end
end

procedure ProcessExit { ret proc -- }
	if (proc@ InitProc@ ==)
		"init exited!\n" Panic
	end

	ret@ proc@ Process_Return + !

	PZOMBIE proc@ Process_Status + !

	proc@ ProcessMurder

	proc@ ProcessFreeResources

	auto i

	auto parent

	proc@ Process_Parent + @ parent!

	if (parent@ 0 ==)
		ThreadPick

		return
	end

	(* do wait stuff *)

	auto wthread
	proc@ Process_WaitedBy + @ wthread!

	if (wthread@ 0 ==)
		(* no thread was specifically waiting for us but there might be a WAITINGANY parent thread *)
		0 i!

		while (i@ THREADNUM <)
			auto tid
			i@ Thread_SIZEOF * ThreadTable@ + tid!

			if (tid@ Thread_Status + @ WAITINGANY ==)
				if (tid@ Thread_Process + @ parent@ ==)
					(* bingo! *)

					tid@ wthread!

					break
				end
			end

			1 i +=
		end

		(* nobody was waiting for it, but might later, so just hop down and return *)
	end

	if (wthread@ 0 ~=)
		(* wake up waiting thread *)

		0 wthread@ Thread_Status + !

		proc@ Process_ProcessID + @ wthread@ Thread_StackFrame + @ TrapFrame_r1 + !

		ret@ wthread@ Thread_StackFrame + @ TrapFrame_r0 + !

		proc@ ProcessFreeSlot
	end

	(* no matter what, we're still exiting *)

	0 i!

	while (i@ PROCNUM <) (* reparent children *)
		auto ch
		i@ Process_SIZEOF * ProcessTable@ + ch!

		if (ch@ Process_Status + @ PFREE ~=)
			if (ch@ Process_Parent + @ proc@ ==)
				InitProc@ ch@ Process_Parent + !
			end
		end

		1 i +=
	end

	ThreadPick
end

procedure ProcessMurder { proc -- }
	auto i
	0 i!

	while (i@ THREADNUM <)
		auto tid
		i@ Thread_SIZEOF * ThreadTable@ + tid!

		if (tid@ Thread_Status + @ SLOT_FREE ~=)
			if (tid@ Thread_Process + @ proc@ ==)
				tid@ ThreadFree
			end
		end

		1 i +=
	end

	if (proc@ Process_ThreadCount + @ 0 >) (* logically, this can't happen... *)
		"ProcessMurder: process wasn't murdered hard enough\n" Panic
	end
end

procedure ProcessFreeResources { proc -- }
	if (proc@ Process_ThreadCount + @ 0 >)
		"ProcessFreeResources: can't free process with extant threads\n" Panic
	end

	if (proc@ Process_Wired + @ ~~)
		proc@ Process_ImageSize + @ 4096 / 1 +
		proc@ Process_ImagePhysAddr + @ PMMFree
	end

	proc@ Process_HeapSize + @ 4096 / 1 +
	proc@ Process_HeapPhysAddr + @ PMMFree

	(* proc@ ProcessFreeSlot *)
end

procedure ProcessInfo { proc -- }
	proc@ Process_Name + "proc name: %s\n" Printf

	proc@ Process_UserID + @ "proc user: %d\n" Printf

	proc@ Process_ImagePhysAddr + @ "proc image phys addr: %x\n" Printf
	proc@ Process_ImageSize + @ "proc image size: %d\n" Printf

	proc@ Process_HeapPhysAddr + @ "proc heap phys addr: %x\n" Printf
	proc@ Process_HeapSize + @ "proc heap size: %d\n" Printf

	proc@ Process_ThreadCount + @ "proc thread count: %d\n" Printf

	proc@ Process_MainThread + @ "proc main thread: %x\n" Printf

	proc@ Process_Wired + @ "proc wired: %d\n" Printf

	proc@ Process_Status + @ "process status: %d\n" Printf

	auto tid
	proc@ Process_MainThread + @ tid!

	tid@ Thread_StackPhysAddr + @ "main thread stack addr: %x\n" Printf
end

procedure ProcessUser { -- user }
	CurrentThread@ Thread_Process + @ Process_UserID + @ user!
end

procedure ProcessSetUserID { uid -- }
	uid@ CurrentThread@ Thread_Process + @ Process_UserID + !
end

procedure ProcessByPID { pid -- process }
	-1 process!

	auto i
	0 i!

	while (i@ PROCNUM <)
		auto thp
		i@ Process_SIZEOF * ProcessTable@ + thp!

		if (thp@ Process_Status + @ PFREE ~=)
			if (thp@ Process_ProcessID + @ pid@ ==)
				thp@ process!
				return
			end
		end

		1 i +=
	end
end

(* we don't start off knowing who init is, so this is
called when the "init" service is first registered.
since init didn't exist, all the boot servers were orphans. this fixes that *)
procedure ReparentOrphans { -- }
	if (InitProc@ 0 ==)
		"ReparentOrphans\n" Panic
	end

	auto i
	0 i!

	while (i@ PROCNUM <)
		auto thp
		i@ Process_SIZEOF * ProcessTable@ + thp!

		if (thp@ Process_Status + @ PFREE ~=)
			if (thp@ Process_Parent + @ 0 ==)
				InitProc@ thp@ Process_Parent + !
			end
		end

		1 i +=
	end
end














