#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/context.h"

var InterruptGet 0
public InterruptGet

var InterruptAck 0
public InterruptAck

const CYCLESLICE 100000

asm "

exception_vector:
	mov   k2, sp ; save old sp in k2,
	             ; this could be a usermode sp, in which case it needs saving,
	             ; or a kernel mode sp, in which case we'll keep using it,
	             ; but it's much easier and faster to save it unconditionally,
	             ; instead of trying to figure it out.

	la    k0, CurrentThread
	l.l   k0, k0, zero      ; k0 = [CurrentThread]

	andi  k1, ers,  RS_USER    ; if the code that just got interrupted was kernel code,
	beq   k1, zero, .waskernel ; don't switch stacks, continue using the kernel mode stacks
	                           ; for this thread.

	lio.l sp, k0, Thread_KernelStackTop ; load new sp from the current thread's structure

.waskernel:
	subi.i sp, Context_SIZEOF   ; reserve space in stack for context save
	sio.l  sp, Context_sp,  k2  ; store the saved sp from above's longwinded comment
	sio.l  sp, Context_ers, ers ; store the interrupted thread's processor mode
	sio.l  sp, Context_epc, epc ; store the interrupted thread's program counter
	sio.l  sp, Context_lr,  lr  ; store the interrupted thread's return address register
	sgpr   sp                   ; save the rest of the general purpose registers
	                            ; what a convenient instruction sgpr is

	mov    a2, badaddr
	mov    a1, ecause
	mov    a0, sp            ; give Exception our context
	jal    Exception         ; call Exception, to handle the exception

	li     badaddr, 0        ; clear badaddr because the processor doesn't do it for us

	lgpr  sp                    ; restore general purpose registers
	lio.l ers, sp, Context_ers  ; restore interrupted thread's processor mode
	lio.l epc, sp, Context_epc  ; restore interrupted thread's program counter
	lio.l lr,  sp, Context_lr   ; restore interrupted thread's return address register
	lio.l sp,  sp, Context_sp   ; restore interrupted thread's stack pointer, just in case
	                            ; it was user code

	rfe ; give control back to the thread

; old new -- 
cswtch:
.global cswtch
	subi.i sp, Context_SIZEOF
	sio.l  sp, Context_sp,  sp
	sio.l  sp, Context_epc, lr
	sio.l  sp, Context_timer, timer
	sio.l  sp, Context_lr,  lr
	sio.l  sp, Context_ers, rs
	sgpr   sp

	s.l    a1, zero, sp
	mov    sp, a0

	lgpr   sp
	lio.l  lr,    sp,   Context_lr
	lio.l  timer, sp,   Context_timer
	lio.l  rs,    sp,   Context_ers
	addi.i sp,    Context_SIZEOF

	ret

CPUIdle:
.global CPUIdle 
	mov t0, rs
	bseti rs, rs, 1
	hlt
	mov rs, t0
	ret

PlatformSetTimer:
.global PlatformSetTimer
	la timer, CYCLESLICE
	ret

ExceptionInit:
.global ExceptionInit
	la ev, exception_vector
	ret

"

extern PlatformSetTimer { -- } (* it's actually in this file but this makes the df compiler happy *)

extern KDebug { -- }

const EXCINTERRUPT 1
const EXCSYS 2
const EXCTIMER 5
const EXCBREAK 6

fn Exception { badaddr ecause tf -- }
	tf@ CurrentThread@ Thread_TrapFrame + !

	if (ecause@ EXCTIMER ==)
		PlatformSetTimer

		Yield
		return
	end

	auto mode
	tf@ Context_ers + @ RS_USER & mode!

	if (mode@ RS_USER ==)
		1 CurrentThread@ Thread_InKernel + !
	end

	if (ecause@ EXCINTERRUPT ==)
		if (InterruptGet@ 0 ==)
			"no interrupt controller\n" Panic
		end

		auto int
		while (InterruptGet@ InterruptGetter dup int!)
			int@ Interrupt
		end
	end elseif (ecause@ EXCSYS ==)
		InterruptEnable

		(* handle syscall ... *)

		0 InterruptRestore
	end elseif (ecause@ EXCBREAK ==)
		CurrentThread@ Thread_TID + @ "breakpoint (tid: %d)\n" Printf

		KDebug
	end else
		ecause@ "ECAUSE: %x\n" Printf
		tf@ Context_epc + @ "EPC: %x\n" Printf
		tf@ Context_ers + @ "ERS: %x\n" Printf
		badaddr@ "BADADDR: %x\n" Printf

		if (mode@ 0 ==)
			(* kernel mode exception, panic *)
			"unexpected kernel mode exception!\n" Panic
		end

		-1 ProcessExit
	end

	if (mode@ RS_USER ==)
		0 CurrentThread@ Thread_InKernel + !
	end

	if (CurrentThread@ Thread_Killed + @)
		ThreadExit
	end
end

asm "

CPUKThreadEntry:
	bseti rs, rs, 1
	bseti rs, rs, 3

	jalr t0

	la a1, .pstring
	li a0, 0
	jal Panic

.pstring:
	.ds kernel thread dropped off
	.db 0xA, 0x0

.align 4

"

fn CPUContextPrepare { entry stack -- ctx }
	stack@ Context_SIZEOF - ctx!

	entry@ ctx@ Context_t0 + !
	pointerof CPUKThreadEntry ctx@ Context_lr + !
	CYCLESLICE ctx@ Context_timer + !
end

asm "

PreemptEnable:
.global PreemptEnable
	mov v0, rs
	bseti rs, rs, 3
	ret

InterruptEnable:
.global InterruptEnable
	bseti rs, rs, 1
	ret

InterruptDisable:
.global InterruptDisable
	mov v0, rs
	bclri rs, rs, 3
	bclri rs, rs, 1
	ret

InterruptRestore:
.global InterruptRestore
	mov rs, a0
	ret

"

table ContextNames
	"t0"    "t1"
	"t2"    "t3"
	"t4"    "a0"
	"a1"    "a2"
	"a3"    "v0"
	"v1"    "s0"
	"s1"    "s2"
	"s3"    "s4"
	"s5"    "s6"
	"s7"    "s7"
	"s9"    "s10"
	"s11"   "s12"
	"s13"   "s14"
	"at"    "tf"

	"sp"
	"ers"
	"epc"
	"lr"
	"timer"
endtable

public ContextNames