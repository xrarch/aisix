#include "<df>/dragonfruit.h"
#include "<inc>/kernel.h"
#include "<inc>/context.h"

var InterruptGet 0
public InterruptGet

var InterruptAck 0
public InterruptAck

const CYCLESLICE 100000

asm "

limn2k_exception:
.global limn2k_exception ; so that it shows up properly in stack traces
	mov   k2, sp ; save old sp in k2,
	             ; this could be a usermode sp, in which case it needs saving,
	             ; or a kernel mode sp, in which case we'll keep using it,
	             ; but it's much easier and faster to save it unconditionally,
	             ; instead of trying to figure it out.

	la    k0, CurrentThread
	l.l   k0, k0, zero      ; k0 = [CurrentThread]

	andi  k1, ers,  RS_USER    ; if the code that just got interrupted was kernel code,
	beq   k1, zero, .waskernel ; don't switch stacks, continue using the kernel mode stacks
	                           ; for this thread.

	lio.l sp, k0, Thread_KernelStackTop ; load new sp from the current thread's structure

.waskernel:
	subi.i sp, Context_SIZEOF   ; reserve space in stack for context save
	sio.l  sp, Context_sp,  k2  ; store the saved sp from above's longwinded comment
	sio.l  sp, Context_ers, ers ; store the interrupted thread's processor mode
	sio.l  sp, Context_epc, epc ; store the interrupted thread's program counter
	sio.l  sp, Context_lr,  lr  ; store the interrupted thread's return address register
	sgpr   sp                   ; save the rest of the general purpose registers
	                            ; what a convenient instruction sgpr is

	mov    a2, badaddr
	mov    a1, ecause
	mov    a0, sp            ; give Exception our context

	subi.i sp, 4
	s.l    sp, zero, zero    ; put a zero link so that stacktraces dont freak out here

	jal    Exception         ; call Exception, to handle the exception

	li     badaddr, 0        ; clear badaddr because the processor doesn't do it for us

	addi.i sp, 4

forkret:

	lgpr  sp                    ; restore general purpose registers
	lio.l ers, sp, Context_ers  ; restore interrupted thread's processor mode
	lio.l epc, sp, Context_epc  ; restore interrupted thread's program counter
	lio.l lr,  sp, Context_lr   ; restore interrupted thread's return address register
	lio.l sp,  sp, Context_sp   ; restore interrupted thread's stack pointer, just in case
	                            ; it was user code

	rfe ; give control back to the thread

; old new -- 
cswtch:
.global cswtch
	subi.i sp, Context_SIZEOF
	sio.l  sp, Context_sp,  sp
	sio.l  sp, Context_epc, lr
	sio.l  sp, Context_timer, timer
	sio.l  sp, Context_lr,  lr
	sio.l  sp, Context_ers, rs
	sgpr   sp

	s.l    a1, zero, sp
	mov    sp, a0

	lgpr   sp
	lio.l  lr,    sp,   Context_lr
	lio.l  timer, sp,   Context_timer
	lio.l  rs,    sp,   Context_ers
	addi.i sp,    Context_SIZEOF

	ret

CPUHlt:
.global CPUHlt
	hlt
	ret

CPUIdle:
.global CPUIdle 
	mov t0, rs
	bseti rs, rs, 1
	hlt
	mov rs, t0
	ret

PlatformSetTimer:
.global PlatformSetTimer
	la timer, CYCLESLICE
	ret

ExceptionInit:
.global ExceptionInit
	la ev, limn2k_exception
	ret

"

extern PlatformSetTimer { -- } (* it's actually in this file but this makes the df compiler happy *)

extern forkret { -- }

extern KDebug { -- }

const EXCINTERRUPT 1
const EXCSYS 2
const EXCTIMER 5
const EXCBREAK 6

externptr DebugNextSched

extern PlatformAlertUser { -- }

fn Exception { badaddr ecause tf -- }
	tf@ CurrentThread@ Thread_TrapFrame + !

	if (ecause@ EXCTIMER ==)
		PlatformSetTimer

		Yield
		return
	end

	auto mode
	tf@ Context_ers + @ RS_USER & mode!

	if (ecause@ EXCINTERRUPT ==)
		if (InterruptGet@ 0 ==)
			"no interrupt controller\n" Panic
		end

		auto int
		while (InterruptGet@ InterruptGetter dup int!)
			int@ Interrupt
		end
	end elseif (ecause@ EXCSYS ==)
		auto sys
		tf@ Context_a0 + @ sys!

		if (sys@ SYSMAX >)
			-EBADSYS tf@ Context_v0 + !
		end else
			[sys@]Syscalls@ sys!

			if (sys@ 0 ==)
				-EBADSYS tf@ Context_v0 + !
			end else
				1 CurrentThread@ Thread_InKernel + !

				if (LockMe ~~)
					InterruptEnable

					tf@ sys@ Syscall tf@ Context_v0 + !

					0 InterruptRestore

					UnlockMe
				end

				0 CurrentThread@ Thread_InKernel + !
			end
		end
	end elseif (ecause@ EXCBREAK ==)
		CurrentThread@ Thread_TID + @ "breakpoint (tid: %d)\n" Printf

		1 DebugNextSched!
	end else
		if (mode@ 0 ==)
			(* kernel mode exception, panic *)
			badaddr@ tf@ Context_ers + @ tf@ Context_epc + @ ecause@ "unexpected kernel mode exception!\necause=%x\nepc=%x\ners=%x\nbadaddr=%x\n" Panic
		end else
			badaddr@ tf@ Context_ers + @ tf@ Context_epc + @ ecause@ "ecause=%x\nepc=%x\ners=%x\nbadaddr=%x\n" Printf
			KDebug
		end

		1 CurrentThread@ Thread_Killed + !
	end

	if (CurrentThread@ Thread_Killed + @)
		ThreadExit
	end
end

asm "

CPUKThreadEntry:
.global CPUKThreadEntry
	subi.i sp, 4
	s.l    sp, zero, zero ; put a zero link so that stacktraces dont freak out here

	bseti rs, rs, 1
	bseti rs, rs, 3

	jalr t0

	la a1, .pstring
	li a0, 0
	jal Panic

.pstring:
	.ds kernel thread dropped off
	.db 0xA, 0x0

.align 4

"

extern CPUKThreadEntry { -- }

fn CPUContextPrepare { a0 a1 entry stack kern -- ctx }
	stack@ Context_SIZEOF - ctx!

	if (kern@)
		entry@ ctx@ Context_t0 + !
		pointerof CPUKThreadEntry ctx@ Context_lr + !
	end else
		entry@ ctx@ Context_epc + !

		RS_USER RS_INT | RS_MMU | RS_TIMER | ctx@ Context_ers + !

		a0@ ctx@ Context_a0 + !
		a1@ ctx@ Context_a1 + !

		Context_SIZEOF ctx -=

		pointerof forkret ctx@ Context_lr + !
	end

	CYCLESLICE ctx@ Context_timer + !
end

asm "

PreemptEnable:
.global PreemptEnable
	mov v0, rs
	bseti rs, rs, 3
	ret

InterruptEnable:
.global InterruptEnable
	bseti rs, rs, 1
	bseti rs, rs, 3
	ret

InterruptDisable:
.global InterruptDisable
	mov v0, rs
	bclri rs, rs, 3
	bclri rs, rs, 1
	ret

InterruptRestore:
.global InterruptRestore
	mov rs, a0
	ret

"

table ContextNames
	"t0"    "t1"
	"t2"    "t3"
	"t4"    "a0"
	"a1"    "a2"
	"a3"    "v0"
	"v1"    "s0"
	"s1"    "s2"
	"s3"    "s4"
	"s5"    "s6"
	"s7"    "s7"
	"s9"    "s10"
	"s11"   "s12"
	"s13"   "s14"
	"at"    "tf"

	"sp"
	"ers"
	"epc"
	"lr"
	"timer"
endtable

public ContextNames