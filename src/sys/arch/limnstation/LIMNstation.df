#include "<df>/dragonfruit.h"
#include "<ll>/rta3x/a3x.h"
#include "<inc>/kernel.h"
#include "<inc>/limnmmu.h"

extern AISIX { ksz args -- ret }

const CompatibleFirmware 30505

var SavedEV 0

asm "

SaveEV:
	la t0, SavedEV
	s.l t0, zero, ev
	ret

RestoreEV:
	la t0, SavedEV
	l.l ev, t0, zero
	ret

"

extern SaveEV { -- }
extern RestoreEV { -- }

fn Main { ksz args -- ret }
	0 ret!

	(* manually clear BSS section, because fileloader only loads flat files,
	and while the linker lets us spit out flat binary files with the BSS section
	trimmed out rather than converted to a massive block of zeroes on disk,
	it does mean we have to clear it ourselves. *)

	auto ptr
	pointerof _bss ptr!

	ptr@
	pointerof _bss_end ptr@ -
	0 memset

	SaveEV

	pointerof PlatformGetc pointerof PlatformPutc KLogAttach

	"\ninitial kernel log to a3x console\n" Printf

	auto vnum
	"/" a3xDeviceSelect
		"versionNum" a3xDGetProperty vnum!
	a3xDeviceExit

	if (vnum@ CompatibleFirmware <)
		"aisix requires newer firmware!\n" Printf
		0 a3xReturn
	end

	"/platform" a3xDeviceSelect
		"model" a3xDGetProperty MachineType!
	a3xDeviceExit

	"/cpu" a3xDeviceSelect
		"model" a3xDGetProperty MachineCPU!
	a3xDeviceExit

	"/bus" a3xDeviceSelect
		"model" a3xDGetProperty MachineBus!
	a3xDeviceExit

	auto tram

	"/memory" a3xDeviceSelect
		"totalRAM" a3xDGetProperty tram!
	a3xDeviceExit

	pointerof _bss_end MachineRAMBase!

	if (MachineRAMBase@ 0xFFF & 0 ~=)
		MachineRAMBase@ 0xFFFFF000 & 0x1000 + MachineRAMBase!
	end

	tram@ MachineRAMBase@ - MachineRAMSize!

	ksz@ args@ AISIX ret!
end

externptr LIMN2KTimeslice

extern DeviceTree { -- }
extern ExceptionInit { -- }
fn PlatformInit { -- }
	ExceptionInit

	auto ts
	"ts" ArgsValue ts!

	if (ts@)
		ts@ atoi LIMN2KTimeslice!
		ts@ Free
	end

	DeviceTree

	'\n' Putc
end

fn PlatformPutc { c -- }
	auto rs
	InterruptDisable rs!

	c@ a3xPutc

	rs@ InterruptRestore
end

fn PlatformGetc { -- c }
	auto rs
	InterruptDisable rs!

	a3xGetc c!

	rs@ InterruptRestore
end

fn PlatformAlertUser { early -- }
	pointerof PlatformGetc pointerof PlatformPutc KLogAttach

	auto gc
	"/gconsole" a3xDevTreeWalk gc!

	if (gc@ early@ ~~ &&)
		gc@ a3xDeviceSelectNode
			"nodraw" a3xDCallMethod drop drop drop drop
		a3xDeviceExit
	end

	a3xConsoleUserOut
end

fn PlatformUnalertUser { -- }
end

asm "

SwitchK3:
	mov k3, a0
	ftlb t0
	ret

"

extern SwitchK3 { newk3 -- }

fn PlatformSwitchSeg { proc -- }
	proc@ Process_TextPhysical + SwitchK3
end

fn PlatformUserToPhys { len user wr -- phys valid }
	if (user@ 0x80000000 &)
		0 valid!
		return
	end

	if (len@ 0 s<)
		0 valid!
		return
	end

	auto seg
	user@ MMUSSHIFT >> seg!

	if (seg@ 2 >=)
		0 valid!
		return
	end

	auto p
	CurrentThread@ Thread_Process + @ p!

	auto b
	p@ Process_TextPhysical + seg@ 8 * + b!

	auto sz
	b@ 4 + @ 12 << sz!

	auto off
	user@ MMUOFFMASK & off!

	if (off@ len@ + sz@ >=)
		0 valid!
		return
	end

	if (wr@ seg@ 0 == &&)
		0 valid!
		return
	end

	b@@ off@ + phys!
	1 valid!
end

fn PlatformPrePanic { -- }
end

fn PlatformPanic { -- }
	-1 FWReturn
end

fn FWReturn { ret -- }
	RestoreEV
	ret@ a3xReturn
end

fn PlatformHalt { haltmode -- }
	InterruptDisable drop

	if (haltmode@ HALT_SHUTDOWN ==)
		1024 FWReturn
	end

	if (haltmode@ HALT_REBOOT ==)
		"/cpu" a3xDeviceSelect
			"reset" a3xDCallMethod drop drop drop drop
		a3xDeviceExit
	end
end