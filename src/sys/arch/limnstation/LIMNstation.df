#include "<df>/dragonfruit.h"
#include "<ll>/rta3x/a3x.h"
#include "<inc>/kernel.h"
#include "<inc>/limnmmu.h"

extern AISIX { ksz args -- ret }

const CompatibleFirmware 30502

fn Main { ksz args -- ret }
	0 ret!

	(* manually clear BSS section, because fileloader only loads flat files,
	and while the linker lets us spit out flat binary files with the BSS section
	trimmed out rather than converted to a massive block of zeroes on disk,
	it does mean we have to clear it ourselves. *)

	auto ptr
	pointerof _bss ptr!

	ptr@
	pointerof _bss_end ptr@ -
	0 memset

	pointerof PlatformGetc pointerof PlatformPutc KLogAttach

	"\ninitial kernel log to a3x console\n" Printf

	auto vnum
	"/" a3xDeviceSelect
		"versionNum" a3xDGetProperty vnum!
	a3xDeviceExit

	if (vnum@ CompatibleFirmware <)
		"aisix requires newer firmware!\n" Printf
		return
	end

	"/platform" a3xDeviceSelect
		"model" a3xDGetProperty MachineType!
	a3xDeviceExit

	"/cpu" a3xDeviceSelect
		"model" a3xDGetProperty MachineCPU!
	a3xDeviceExit

	"/bus" a3xDeviceSelect
		"model" a3xDGetProperty MachineBus!
	a3xDeviceExit

	auto tram

	"/memory" a3xDeviceSelect
		"totalRAM" a3xDGetProperty tram!
	a3xDeviceExit

	pointerof _bss_end MachineRAMBase!

	if (MachineRAMBase@ 0xFFF & 0 ~=)
		MachineRAMBase@ 0xFFFFF000 & 0x1000 + MachineRAMBase!
	end

	tram@ MachineRAMBase@ - MachineRAMSize!

	ksz@ args@ AISIX ret!
end

extern DeviceTree { -- }
extern ExceptionInit { -- }
extern LGFXExclude { -- }
fn PlatformInit { -- }
	ExceptionInit

	DeviceTree

	LGFXExclude

	'\n' Putc
end

fn PlatformPutc { c -- }
	auto rs
	InterruptDisable rs!

	c@ a3xPutc

	rs@ InterruptRestore
end

fn PlatformGetc { -- c }
	auto rs
	InterruptDisable rs!

	a3xGetc c!

	rs@ InterruptRestore
end

fn PlatformAlertUser { -- }
	pointerof PlatformGetc pointerof PlatformPutc KLogAttach

	a3xConsoleUserOut
end

fn PlatformSwitchSeg { proc -- }
	auto base
	MMUSEGBASE base!

	auto flag

	proc@ Process_TextPhysical + @ MMUPSHIFT >> flag!
	MMUPBIT flag |=
	flag@ base@ MMUSEG0FLAG + !
	proc@ Process_TextPages + @ base@ MMUSEG0SIZE + !

	proc@ Process_DataPhysical + @ MMUPSHIFT >> flag!
	MMUPBIT flag |=
	MMURWBIT flag |=
	flag@ base@ MMUSEG1FLAG + !
	proc@ Process_DataPages + @ base@ MMUSEG1SIZE + !

	0 flag!
	if (proc@ Process_UPhysical + @)
		proc@ Process_UPhysical + @ MMUPSHIFT >> flag!
		MMUPBIT flag |=
		MMURWBIT flag |=
	end
	flag@ base@ MMUSEG2FLAG + !
	proc@ Process_UPages + @ base@ MMUSEG2SIZE + !

	0 base@ MMUSEG3FLAG + !
end

fn PlatformUserToPhys { len user wr -- phys valid }
	auto seg
	user@ MMUSSHIFT >> seg!
	auto off
	user@ MMUOFFMASK & off!

	auto b
	seg@ 8 * MMUSEGBASE + b!

	auto flag
	b@ MMUSEG0FLAG + @ flag!

	auto sz
	b@ MMUSEG0SIZE + @ sz!

	if (len@ 0 s<)
		0 valid!
		return
	end

	if (flag@ MMUPBIT & ~~)
		0 valid!
		return
	end elseif (off@ len@ + sz@ MMUPSHIFT << >=)
		0 valid!
		return
	end elseif (flag@ MMURWBIT & ~~ wr@ &&)
		0 valid!
		return
	end

	flag@ MMUPHYMASK & MMUPSHIFT << off@ + phys!
	1 valid!
end